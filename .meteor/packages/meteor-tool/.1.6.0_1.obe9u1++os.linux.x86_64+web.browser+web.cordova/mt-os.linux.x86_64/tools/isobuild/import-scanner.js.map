{"version":3,"sources":["/tools/isobuild/import-scanner.js"],"names":["module1","module","export","default","ImportScanner","assert","watch","require","v","inspect","Script","isString","isEmpty","has","keys","each","map","omit","sha1","archMatches","matches","findImportedModuleIdentifiers","cssToCommonJS","buildmessage","LRU","Profile","SourceNode","SourceMapConsumer","pathJoin","pathRelative","pathNormalize","pathDirname","pathBasename","pathExtname","pathIsAbsolute","convertToOSPath","convertToPosixPath","optimisticReadFile","optimisticStatOrNull","optimisticHashOrNull","shouldWatch","Resolver","fakeFileStat","isFile","isDirectory","fakeSymbol","Symbol","defaultExtensionHandlers","dataString","replace","file","jsonData","JSON","parse","stringify","hash","scriptParseCache","Object","create","canBeParsedAsPlainJS","result","e","IMPORT_SCANNER_CACHE","max","length","ids","total","info","id","constructor","name","bundleArch","extensions","sourceRoot","nodeModulesPaths","watchSet","ok","absPathToOutputIndex","allMissingModules","outputFiles","resolver","getOrCreate","caller","targetArch","statOrNull","absPath","stat","_getFile","toLowerCase","_addFile","old","implicit","push","addInputFiles","files","forEach","_checkSourceAndTargetPaths","sourcePath","dotExt","type","data","toString","call","Buffer","from","imported","installPath","_getInstallPath","_combineFiles","_getSourcePath","targetPath","absSourcePath","absTargetPath","sourceFile","servePath","deps","lazy","relativeId","_getRelativeImportId","join","possiblySpurious","dynamic","oldFile","newFile","checkProperty","fuzzyCase","Error","getChunk","consumer","sourceMap","node","fromStringWithSourceMap","code","combinedDataString","combinedSourceMap","toStringWithSourceMap","toJSON","mappings","scanImports","_scanFile","scanMissingModules","missingModules","Array","isArray","newlyMissing","newlyAdded","previousAllMissingModules","staticImportInfo","dynamicImportInfo","some","importInfo","parentWasDynamic","mergeMissing","target","source","importInfoList","pathToIndex","index","parentPath","getOutputFiles","filter","relPath","startsWith","_joinAndStat","path","_findImportedModuleIdentifiers","get","set","_resolve","parentFile","forDynamicImport","resolved","resolve","_onMissing","packageJsonMap","helpers","pkg","packageJsonFile","_addPkgJsonToOutput","childPath","indexOf","charAt","error","message","$ParseError","line","loc","column","isWebBrowser","absImportedPath","depFile","notStrictEqual","endsWith","_readModule","assign","isWeb","_readFile","contents","addFile","ext","charCodeAt","slice","_getNodeModulesInstallPath","_getSourceRootInstallPath","relPathWithinNodeModules","dirs","_splitPath","isApp","bundlingForWeb","topLevelDir","dir","partsInReverse","reverse","absParentPath","isNative","stubId","getNativeStubId","packageName","missing","pkgJsonPath","value","key","isIdentifier","test","prop","relPkgJsonPath","pkgFile","funcName","prototype"],"mappings":"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","file":"tools/isobuild/import-scanner.js.map","sourcesContent":["import assert from \"assert\";\nimport {inspect} from \"util\";\nimport {Script} from \"vm\";\nimport {\n  isString, isEmpty, has, keys, each, map, omit,\n} from \"underscore\";\nimport {sha1} from \"../fs/watch.js\";\nimport {matches as archMatches} from \"../utils/archinfo.js\";\nimport {findImportedModuleIdentifiers} from \"./js-analyze.js\";\nimport {cssToCommonJS} from \"./css-modules.js\";\nimport buildmessage from \"../utils/buildmessage.js\";\nimport LRU from \"lru-cache\";\nimport {Profile} from \"../tool-env/profile.js\";\nimport {SourceNode, SourceMapConsumer} from \"source-map\";\nimport {\n  pathJoin,\n  pathRelative,\n  pathNormalize,\n  pathDirname,\n  pathBasename,\n  pathExtname,\n  pathIsAbsolute,\n  convertToOSPath,\n  convertToPosixPath,\n} from \"../fs/files.js\";\n\nimport {\n  optimisticReadFile,\n  optimisticStatOrNull,\n  optimisticHashOrNull,\n  shouldWatch,\n} from \"../fs/optimistic.js\";\n\nimport Resolver from \"./resolver.js\";\n\nconst fakeFileStat = {\n  isFile() {\n    return true;\n  },\n\n  isDirectory() {\n    return false;\n  }\n};\n\n// Symbol used by scanMissingModules to mark certain files as temporary,\n// to prevent them from being added to scanner.outputFiles.\nconst fakeSymbol = Symbol(\"fake\");\n\n// Default handlers for well-known file extensions.\n// Note that these function expect strings, not Buffer objects.\nconst defaultExtensionHandlers = {\n  \".js\"(dataString) {\n    // Strip any #! line from the beginning of the file.\n    return dataString.replace(/^#![^\\n]*/, \"\");\n  },\n\n  \".json\"(dataString) {\n    const file = this;\n    file.jsonData = JSON.parse(dataString);\n    return \"module.exports = \" +\n      JSON.stringify(file.jsonData, null, 2) +\n      \";\\n\";\n  },\n\n  \".css\"(dataString, hash) {\n    return cssToCommonJS(dataString, hash);\n  }\n};\n\n// This is just a map from hashes to booleans, so it doesn't need full LRU\n// eviction logic.\nconst scriptParseCache = Object.create(null);\n\nfunction canBeParsedAsPlainJS(dataString, hash) {\n  if (hash && has(scriptParseCache, hash)) {\n    return scriptParseCache[hash];\n  }\n\n  try {\n    var result = !! new Script(dataString);\n  } catch (e) {\n    result = false;\n  }\n\n  if (hash) {\n    scriptParseCache[hash] = result;\n  }\n\n  return result;\n}\n\n// Map from SHA (which is already calculated, so free for us)\n// to the results of calling findImportedModuleIdentifiers.\n// Each entry is an array of strings, and this is a case where\n// the computation is expensive but the output is very small.\n// The cache can be global because findImportedModuleIdentifiers\n// is a pure function, and that way it applies across instances\n// of ImportScanner (which do not persist across builds).\nconst IMPORT_SCANNER_CACHE = new LRU({\n  max: 1024*1024,\n  length(ids) {\n    let total = 40; // size of key\n    each(ids, (info, id) => { total += id.length; });\n    return total;\n  }\n});\n\nexport default class ImportScanner {\n  constructor({\n    name,\n    bundleArch,\n    extensions,\n    sourceRoot,\n    nodeModulesPaths = [],\n    watchSet,\n  }) {\n    assert.ok(isString(sourceRoot));\n\n    this.name = name;\n    this.bundleArch = bundleArch;\n    this.sourceRoot = sourceRoot;\n    this.nodeModulesPaths = nodeModulesPaths;\n    this.watchSet = watchSet;\n    this.absPathToOutputIndex = Object.create(null);\n    this.allMissingModules = Object.create(null);\n    this.outputFiles = [];\n\n    this.resolver = Resolver.getOrCreate({\n      caller: \"ImportScanner#constructor\",\n      sourceRoot,\n      targetArch: bundleArch,\n      extensions,\n      nodeModulesPaths,\n    });\n\n    // Since Resolver.getOrCreate may have returned a cached Resolver\n    // instance, it's important to update its statOrNull method so that it\n    // is bound to this ImportScanner object rather than the previous one.\n    this.resolver.statOrNull = (absPath) => {\n      const stat = optimisticStatOrNull(absPath);\n      if (stat) {\n        return stat;\n      }\n\n      const file = this._getFile(absPath);\n      if (file) {\n        return fakeFileStat;\n      }\n\n      return null;\n    };\n  }\n\n  _getFile(absPath) {\n    absPath = absPath.toLowerCase();\n    if (has(this.absPathToOutputIndex, absPath)) {\n      return this.outputFiles[this.absPathToOutputIndex[absPath]];\n    }\n  }\n\n  _addFile(absPath, file) {\n    if (! file || file[fakeSymbol]) {\n      // Return file without adding it to this.outputFiles.\n      return file;\n    }\n\n    absPath = absPath.toLowerCase();\n    const old = this.absPathToOutputIndex[absPath];\n\n    if (old) {\n      // If the old file is just an empty stub, let the new file take\n      // precedence over it.\n      if (old.implicit === true) {\n        return this.absPathToOutputIndex[absPath] = file;\n      }\n\n      // If the new file is just an empty stub, pretend the _addFile\n      // succeeded by returning the old file, so that we won't try to call\n      // _combineFiles needlessly.\n      if (file.implicit === true) {\n        return old;\n      }\n\n    } else {\n      this.absPathToOutputIndex[absPath] =\n        this.outputFiles.push(file) - 1;\n\n      return file;\n    }\n  }\n\n  addInputFiles(files) {\n    files.forEach(file => {\n      this._checkSourceAndTargetPaths(file);\n\n      // Note: this absolute path may not necessarily exist on the file\n      // system, but any import statements or require calls in file.data\n      // will be interpreted relative to this path, so it needs to be\n      // something plausible. #6411 #6383\n      const absPath = pathJoin(this.sourceRoot, file.sourcePath);\n\n      const dotExt = \".\" + file.type;\n      const dataString = file.data.toString(\"utf8\");\n      file.dataString = defaultExtensionHandlers[dotExt].call(\n        file,\n        dataString,\n        file.hash,\n      );\n\n      if (! (file.data instanceof Buffer) ||\n          file.dataString !== dataString) {\n        file.data = Buffer.from(file.dataString, \"utf8\");\n      }\n\n      // This property can have values false, true, \"dynamic\" (which\n      // indicates that the file has been imported, but only dynamically).\n      file.imported = false;\n\n      file.installPath = file.installPath || this._getInstallPath(absPath);\n\n      if (! this._addFile(absPath, file)) {\n        // Collisions can happen if a compiler plugin calls addJavaScript\n        // multiple times with the same sourcePath. #6422\n        this._combineFiles(this._getFile(absPath), file);\n      }\n    });\n\n    return this;\n  }\n\n  // Make sure file.sourcePath is defined, and handle the possibility that\n  // file.targetPath differs from file.sourcePath.\n  _checkSourceAndTargetPaths(file) {\n    file.sourcePath = this._getSourcePath(file);\n\n    if (! isString(file.targetPath)) {\n      return;\n    }\n\n    file.targetPath = pathNormalize(pathJoin(\".\", file.targetPath));\n\n    if (file.targetPath !== file.sourcePath) {\n      const absSourcePath = pathJoin(this.sourceRoot, file.sourcePath);\n      const absTargetPath = pathJoin(this.sourceRoot, file.targetPath);\n\n      // If file.targetPath differs from file.sourcePath, generate a new\n      // file object with that .sourcePath that imports the original file.\n      // This allows either the .sourcePath or the .targetPath to be used\n      // when importing the original file, and also allows multiple files\n      // to have the same .sourcePath but different .targetPaths.\n      let sourceFile = this._getFile(absSourcePath);\n      if (! sourceFile) {\n        const installPath = this._getInstallPath(absSourcePath);\n        sourceFile = this._addFile(absSourcePath, {\n          type: file.type,\n          sourcePath: file.sourcePath,\n          servePath: installPath,\n          installPath,\n          dataString: \"\",\n          deps: {},\n          lazy: true,\n          imported: false,\n        });\n      }\n\n      // Make sure the original file gets installed at the target path\n      // instead of the source path.\n      file.installPath = this._getInstallPath(absTargetPath);\n      file.sourcePath = file.targetPath;\n\n      const relativeId = this._getRelativeImportId(\n        absSourcePath,\n        absTargetPath,\n      );\n\n      // Set the contents of the source module to import the target\n      // module(s), combining their exports on the source module's exports\n      // object using the module.watch live binding system. This is better\n      // than `Object.assign(exports, require(relativeId))` because it\n      // allows the exports to change in the future, and better than\n      // `module.exports = require(relativeId)` because it preserves the\n      // original module.exports object, avoiding problems with circular\n      // dependencies (#9176, #9190).\n      //\n      // If there could be only one target module, we could do something\n      // less clever here (like using an identifier string alias), but\n      // unfortunately we have to tolerate the possibility of a compiler\n      // plugin calling inputFile.addJavaScript multiple times for the\n      // same source file (see discussion in #9176), with different target\n      // paths, code, laziness, etc.\n      sourceFile.dataString += [\n        \"module.watch(require(\" + JSON.stringify(relativeId) + \"), {\",\n        '  \"*\": module.makeNsSetter()',\n        \"});\",\n        \"\"\n      ].join(\"\\n\");\n      sourceFile.data = Buffer.from(sourceFile.dataString, \"utf8\");\n      sourceFile.hash = sha1(sourceFile.data);\n      sourceFile.deps[relativeId] = {\n        installPath: file.installPath,\n        possiblySpurious: false,\n        dynamic: false\n      };\n    }\n  }\n\n  // Concatenate the contents of oldFile and newFile, combining source\n  // maps and updating all other properties appropriately. Once this\n  // combination is done, oldFile should be kept and newFile discarded.\n  _combineFiles(oldFile, newFile) {\n    function checkProperty(name) {\n      if (has(oldFile, name)) {\n        if (! has(newFile, name)) {\n          newFile[name] = oldFile[name];\n        }\n      } else if (has(newFile, name)) {\n        oldFile[name] = newFile[name];\n      }\n\n      if (oldFile[name] !== newFile[name]) {\n        const fuzzyCase =\n          oldFile.sourcePath.toLowerCase() === newFile.sourcePath.toLowerCase();\n\n        throw new Error(\n          \"Attempting to combine different files\" +\n            ( fuzzyCase ? \" (is the filename case slightly different?)\" : \"\") +\n            \":\\n\" +\n            inspect(omit(oldFile, \"dataString\")) + \"\\n\" +\n            inspect(omit(newFile, \"dataString\")) + \"\\n\"\n        );\n      }\n    }\n\n    // Since we're concatenating the files together, they must be either\n    // both lazy or both eager. Same for bareness.\n    checkProperty(\"lazy\");\n    checkProperty(\"bare\");\n\n    function getChunk(file) {\n      const consumer = file.sourceMap &&\n        new SourceMapConsumer(file.sourceMap);\n      const node = consumer &&\n        SourceNode.fromStringWithSourceMap(file.dataString, consumer);\n      return node || file.dataString;\n    }\n\n    const {\n      code: combinedDataString,\n      map: combinedSourceMap,\n    } = new SourceNode(null, null, null, [\n      getChunk(oldFile),\n      \"\\n\\n\",\n      getChunk(newFile)\n    ]).toStringWithSourceMap({\n      file: oldFile.servePath || newFile.servePath\n    });\n\n    oldFile.dataString = combinedDataString;\n    oldFile.data = Buffer.from(oldFile.dataString, \"utf8\");\n    oldFile.hash = sha1(oldFile.data);\n\n    // If either oldFile or newFile has been imported non-dynamically,\n    // then oldFile.imported needs to be === true. Otherwise we simply set\n    // oldFile.imported = oldFile.imported || newFile.imported, which\n    // could be either \"dynamic\" or false.\n    oldFile.imported =\n      oldFile.imported === true ||\n      newFile.imported === true ||\n      oldFile.imported ||\n      newFile.imported;\n\n    oldFile.sourceMap = combinedSourceMap.toJSON();\n    if (! oldFile.sourceMap.mappings) {\n      oldFile.sourceMap = null;\n    }\n  }\n\n  scanImports() {\n    this.outputFiles.forEach(file => {\n      if (! file.lazy) {\n        this._scanFile(file);\n      }\n    });\n\n    return this;\n  }\n\n  scanMissingModules(missingModules) {\n    assert.ok(missingModules);\n    assert.ok(typeof missingModules === \"object\");\n    assert.ok(! Array.isArray(missingModules));\n\n    const newlyMissing = Object.create(null);\n    const newlyAdded = Object.create(null);\n\n    if (! isEmpty(missingModules)) {\n      const previousAllMissingModules = this.allMissingModules;\n      this.allMissingModules = newlyMissing;\n\n      Object.keys(missingModules).forEach(id => {\n        let staticImportInfo = null;\n        let dynamicImportInfo = null;\n\n        // Although it would be logically valid to call this._scanFile for\n        // each and every importInfo object, there can be a lot of them\n        // (hundreds, maybe thousands). The only relevant difference is\n        // whether the file is being scanned as a dynamic import or not,\n        // so we can get away with calling this._scanFile at most twice,\n        // with a representative importInfo object of each kind.\n        missingModules[id].some(importInfo => {\n          if (importInfo.parentWasDynamic ||\n              importInfo.dynamic) {\n            dynamicImportInfo = dynamicImportInfo || importInfo;\n          } else {\n            staticImportInfo = staticImportInfo || importInfo;\n          }\n\n          // Stop when/if both variables have been initialized.\n          return staticImportInfo && dynamicImportInfo;\n        });\n\n        if (staticImportInfo) {\n          this._scanFile({\n            sourcePath: \"fake.js\",\n            [fakeSymbol]: true,\n            // By specifying the .deps property of this fake file ahead of\n            // time, we can avoid calling findImportedModuleIdentifiers in\n            // the _scanFile method, which is important because this file\n            // doesn't have a .data or .dataString property.\n            deps: { [id]: staticImportInfo }\n          }, false); // !forDynamicImport\n        }\n\n        if (dynamicImportInfo) {\n          this._scanFile({\n            sourcePath: \"fake.js\",\n            [fakeSymbol]: true,\n            deps: { [id]: dynamicImportInfo }\n          }, true); // forDynamicImport\n        }\n      });\n\n      this.allMissingModules = previousAllMissingModules;\n\n      Object.keys(missingModules).forEach(id => {\n        if (! has(newlyMissing, id)) {\n          // We don't need to use ImportScanner.mergeMissing here because\n          // this is the first time newlyAdded[id] has been assigned.\n          newlyAdded[id] = missingModules[id];\n        }\n      });\n\n      // Remove previously seen missing module identifiers from\n      // newlyMissing and merge the new identifiers back into\n      // this.allMissingModules.\n      Object.keys(newlyMissing).forEach(id => {\n        if (has(previousAllMissingModules, id)) {\n          delete newlyMissing[id];\n        } else {\n          ImportScanner.mergeMissing(\n            previousAllMissingModules,\n            { [id]: newlyMissing[id] }\n          );\n        }\n      });\n    }\n\n    return {\n      newlyAdded,\n      newlyMissing,\n    };\n  }\n\n  // Helper for copying the properties of source into target,\n  // concatenating values (which must be arrays) if a property already\n  // exists. The array elements should be importInfo objects, and will be\n  // deduplicated according to their .parentPath properties.\n  static mergeMissing(target, source) {\n    keys(source).forEach(id => {\n      const importInfoList = source[id];\n      const pathToIndex = Object.create(null);\n\n      if (! has(target, id)) {\n        target[id] = [];\n      } else {\n        target[id].forEach((importInfo, index) => {\n          pathToIndex[importInfo.parentPath] = index;\n        });\n      }\n\n      importInfoList.forEach(importInfo => {\n        const { parentPath } = importInfo;\n        if (typeof parentPath === \"string\") {\n          const index = pathToIndex[parentPath];\n          if (typeof index === \"number\") {\n            // If an importInfo object with this .parentPath is already\n            // present in the target[id] array, replace it.\n            target[id][index] = importInfo;\n            return;\n          }\n        }\n\n        target[id].push(importInfo);\n      });\n    });\n  }\n\n  getOutputFiles() {\n    // Return all installable output files that are either eager or\n    // imported (statically or dynamically).\n    return this.outputFiles.filter(file => {\n      return file.installPath &&\n        ! file[fakeSymbol] &&\n        (! file.lazy ||\n         file.imported === true ||\n         file.imported === \"dynamic\");\n    });\n  }\n\n  _getSourcePath(file) {\n    let sourcePath = file.sourcePath;\n    if (sourcePath) {\n      if (pathIsAbsolute(sourcePath)) {\n        try {\n          var relPath = pathRelative(this.sourceRoot, sourcePath);\n\n        } finally {\n          if (! relPath || relPath.startsWith(\"..\")) {\n            if (this.resolver._joinAndStat(this.sourceRoot, sourcePath)) {\n              // If sourcePath exists as a path relative to this.sourceRoot,\n              // strip away the leading / that made it look absolute.\n              return pathNormalize(pathJoin(\".\", sourcePath));\n            }\n\n            if (relPath) {\n              throw new Error(\"sourcePath outside sourceRoot: \" + sourcePath);\n            }\n\n            // If pathRelative threw an exception above, and we were not\n            // able to handle the problem, it will continue propagating\n            // from this finally block.\n          }\n        }\n\n        sourcePath = relPath;\n      }\n\n    } else if (file.servePath) {\n      sourcePath = convertToOSPath(file.servePath.replace(/^\\//, \"\"));\n\n    } else if (file.path) {\n      sourcePath = file.path;\n    }\n\n    return pathNormalize(pathJoin(\".\", sourcePath));\n  }\n\n  _findImportedModuleIdentifiers(file) {\n    if (IMPORT_SCANNER_CACHE.has(file.hash)) {\n      return IMPORT_SCANNER_CACHE.get(file.hash);\n    }\n\n    const result = findImportedModuleIdentifiers(\n      file.dataString,\n      file.hash,\n    );\n\n    // there should always be file.hash, but better safe than sorry\n    if (file.hash) {\n      IMPORT_SCANNER_CACHE.set(file.hash, result);\n    }\n\n    return result;\n  }\n\n  _resolve(parentFile, id, forDynamicImport = false) {\n    const absPath = pathJoin(this.sourceRoot, parentFile.sourcePath);\n    const resolved = this.resolver.resolve(id, absPath);\n\n    if (resolved === \"missing\") {\n      return this._onMissing(parentFile, id, forDynamicImport);\n    }\n\n    if (resolved && resolved.packageJsonMap) {\n      const info = parentFile.deps[id];\n      info.helpers = info.helpers || {};\n\n      each(resolved.packageJsonMap, (pkg, path) => {\n        const packageJsonFile =\n          this._addPkgJsonToOutput(path, pkg, forDynamicImport);\n\n        if (! parentFile.installPath) {\n          // If parentFile is not installable, then we won't return it\n          // from getOutputFiles, so we don't need to worry about\n          // recording any parentFile.deps[id].helpers.\n          return;\n        }\n\n        const relativeId = this._getRelativeImportId(\n          parentFile.installPath,\n          packageJsonFile.installPath\n        );\n\n        // Although not explicitly imported, any package.json modules\n        // involved in resolving this import should be recorded as\n        // implicit \"helpers.\"\n        info.helpers[relativeId] = forDynamicImport;\n      });\n    }\n\n    return resolved;\n  }\n\n  _getRelativeImportId(parentPath, childPath) {\n    const relativeId = convertToPosixPath(pathRelative(\n      pathDirname(parentPath),\n      childPath\n    ), true);\n\n    // If the result of pathRelative does not already start with a \".\" or\n    // a \"/\", prepend a \"./\" to make it a valid relative identifier\n    // according to CommonJS syntax.\n    if (\"./\".indexOf(relativeId.charAt(0)) < 0) {\n      return \"./\" + relativeId;\n    }\n\n    return relativeId;\n  }\n\n  _scanFile(file, forDynamicImport = false) {\n    if (file.imported === true) {\n      // If we've already scanned this file non-dynamically, then we don't\n      // need to scan it again.\n      return;\n    }\n\n    if (forDynamicImport &&\n        file.imported === \"dynamic\") {\n      // If we've already scanned this file dynamically, then we don't\n      // need to scan it dynamically again.\n      return;\n    }\n\n    // Set file.imported to a truthy value (either \"dynamic\" or true).\n    file.imported = forDynamicImport ? \"dynamic\" : true;\n\n    if (file.error) {\n      // Any errors reported to InputFile#error were saved but not\n      // reported at compilation time. Now that we know the file has been\n      // imported, it's time to report those errors.\n      buildmessage.error(\n        file.error.message,\n        file.error.info\n      );\n      return;\n    }\n\n    try {\n      file.deps = file.deps || this._findImportedModuleIdentifiers(file);\n    } catch (e) {\n      if (e.$ParseError) {\n        buildmessage.error(e.message, {\n          file: file.sourcePath,\n          line: e.loc.line,\n          column: e.loc.column,\n        });\n        return;\n      }\n      throw e;\n    }\n\n    each(file.deps, (info, id) => {\n      // Asynchronous module fetching only really makes sense in the\n      // browser (even though it works equally well on the server), so\n      // it's better if forDynamicImport never becomes true on the server.\n      const dynamic = this.isWebBrowser() &&\n        (forDynamicImport ||\n         info.parentWasDynamic ||\n         info.dynamic);\n\n      const resolved = this._resolve(file, id, dynamic);\n      if (! resolved) {\n        return;\n      }\n\n      const absImportedPath = resolved.path;\n\n      let depFile = this._getFile(absImportedPath);\n      if (depFile) {\n        // We should never have stored a fake file in this.outputFiles, so\n        // it's surprising if depFile[fakeSymbol] is true.\n        assert.notStrictEqual(depFile[fakeSymbol], true);\n\n        // If the module is an implicit package.json stub, update to the\n        // explicit version now.\n        if (depFile.jsonData &&\n            depFile.installPath.endsWith(\"/package.json\") &&\n            depFile.implicit === true) {\n          const file = this._readModule(absImportedPath);\n          if (file) {\n            depFile.implicit = false;\n            Object.assign(depFile, file);\n          }\n        }\n\n        // If depFile has already been scanned, this._scanFile will return\n        // immediately thanks to the depFile.imported-checking logic at\n        // the top of the method.\n        this._scanFile(depFile, dynamic);\n\n        return;\n      }\n\n      const installPath = this._getInstallPath(absImportedPath);\n      if (! installPath) {\n        // The given path cannot be installed on this architecture.\n        return;\n      }\n\n      info.installPath = installPath;\n\n      // If the module is not readable, _readModule may return\n      // null. Otherwise it will return an object with .data, .dataString,\n      // and .hash properties.\n      depFile = this._readModule(absImportedPath);\n      if (! depFile) {\n        return;\n      }\n\n      depFile.type = \"js\"; // TODO Is this correct?\n      depFile.sourcePath = pathRelative(this.sourceRoot, absImportedPath);\n      depFile.installPath = installPath;\n      depFile.servePath = installPath;\n      depFile.lazy = true;\n      // Setting depFile.imported = false is necessary so that\n      // this._scanFile(depFile, dynamic) doesn't think the file has been\n      // scanned already and return immediately.\n      depFile.imported = false;\n\n      // Append this file to the output array and record its index.\n      this._addFile(absImportedPath, depFile);\n\n      // On the server, modules in node_modules directories will be\n      // handled natively by Node, so we don't need to build a\n      // meteorInstall-style bundle beyond the entry-point module.\n      if (! this.isWeb() &&\n          depFile.installPath.startsWith(\"node_modules/\") &&\n          // If optimistic functions care about this file, e.g. because it\n          // resides in a linked npm package, then we should allow it to\n          // be watched by including it in the server bundle by not\n          // returning here. Note that inclusion in the server bundle is\n          // an unnecessary consequence of this logic, since Node will\n          // still evaluate this module natively on the server. What we\n          // really care about is watching the file for changes.\n          ! shouldWatch(absImportedPath)) {\n        // Since we're not going to call this._scanFile(depFile, dynamic)\n        // below, this is our last chance to update depFile.imported.\n        depFile.imported = dynamic ? \"dynamic\" : true;\n        return;\n      }\n\n      this._scanFile(depFile, dynamic);\n    });\n  }\n\n  isWeb() {\n    // Returns true for web.cordova as well as web.browser.\n    return ! archMatches(this.bundleArch, \"os\");\n  }\n\n  isWebBrowser() {\n    return archMatches(this.bundleArch, \"web.browser\");\n  }\n\n  _readFile(absPath) {\n    const contents = optimisticReadFile(absPath);\n    const hash = optimisticHashOrNull(absPath);\n\n    this.watchSet.addFile(absPath, hash);\n\n    return {\n      data: contents,\n      dataString: contents.toString(\"utf8\"),\n      hash\n    };\n  }\n\n  _readModule(absPath) {\n    let ext = pathExtname(absPath).toLowerCase();\n\n    if (ext === \".node\") {\n      const dataString = \"throw new Error(\" + JSON.stringify(\n        this.isWeb()\n          ? \"cannot load native .node modules on the client\"\n          : \"module.useNode() must succeed for native .node modules\"\n      ) + \");\\n\";\n\n      const data = Buffer.from(dataString, \"utf8\");\n      const hash = sha1(data);\n\n      return { data, dataString, hash };\n    }\n\n    try {\n      var info = this._readFile(absPath);\n    } catch (e) {\n      if (e.code !== \"ENOENT\") throw e;\n      return null;\n    }\n\n    const dataString = info.dataString;\n\n    // Same logic/comment as stripBOM in node/lib/module.js:\n    // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n    // because the buffer-to-string conversion in `fs.readFileSync()`\n    // translates it to FEFF, the UTF-16 BOM.\n    if (info.dataString.charCodeAt(0) === 0xfeff) {\n      info.dataString = info.dataString.slice(1);\n    }\n\n    if (! has(defaultExtensionHandlers, ext)) {\n      if (canBeParsedAsPlainJS(dataString)) {\n        ext = \".js\";\n      } else {\n        return null;\n      }\n    }\n\n    info.dataString = defaultExtensionHandlers[ext].call(\n      info,\n      info.dataString,\n      info.hash,\n    );\n\n    if (info.dataString !== dataString) {\n      info.data = Buffer.from(info.dataString, \"utf8\");\n    }\n\n    return info;\n  }\n\n  // Returns a relative path indicating where to install the given file\n  // via meteorInstall. May return undefined if the file should not be\n  // installed on the current architecture.\n  _getInstallPath(absPath) {\n    let path =\n      this._getNodeModulesInstallPath(absPath) ||\n      this._getSourceRootInstallPath(absPath);\n\n    if (! path) {\n      return;\n    }\n\n    if (this.name) {\n      // If we're bundling a package, prefix path with\n      // node_modules/<package name>/.\n      path = pathJoin(\n        \"node_modules\",\n        \"meteor\",\n        this.name.replace(/^local-test[:_]/, \"\"),\n        path,\n      );\n    }\n\n    // Install paths should always be delimited by /.\n    return convertToPosixPath(path);\n  }\n\n  _getNodeModulesInstallPath(absPath) {\n    let installPath;\n\n    this.nodeModulesPaths.some(path => {\n      const relPathWithinNodeModules = pathRelative(path, absPath);\n\n      if (relPathWithinNodeModules.startsWith(\"..\")) {\n        // absPath is not a subdirectory of path.\n        return;\n      }\n\n      // Install the module into the local node_modules directory within\n      // this app or package.\n      return installPath = pathJoin(\n        \"node_modules\",\n        relPathWithinNodeModules\n      );\n    });\n\n    return installPath;\n  }\n\n  _getSourceRootInstallPath(absPath) {\n    const installPath = pathRelative(this.sourceRoot, absPath);\n\n    if (installPath.startsWith(\"..\")) {\n      // absPath is not a subdirectory of this.sourceRoot.\n      return;\n    }\n\n    const dirs = this._splitPath(pathDirname(installPath));\n    const isApp = ! this.name;\n    const bundlingForWeb = this.isWeb();\n\n    const topLevelDir = dirs[0];\n    if (topLevelDir === \"private\" ||\n        topLevelDir === \"packages\" ||\n        topLevelDir === \"programs\" ||\n        topLevelDir === \"cordova-build-override\") {\n      // Don't load anything from these special top-level directories\n      return;\n    }\n\n    for (let dir of dirs) {\n      if (dir.charAt(0) === \".\") {\n        // Files/directories whose names start with a dot are never loaded\n        return;\n      }\n\n      if (isApp) {\n        if (bundlingForWeb) {\n          if (dir === \"server\") {\n            // If we're bundling an app for a client architecture, any files\n            // contained by a server-only directory that is not contained by\n            // a node_modules directory must be ignored.\n            return;\n          }\n        } else if (dir === \"client\") {\n          // If we're bundling an app for a server architecture, any files\n          // contained by a client-only directory that is not contained by\n          // a node_modules directory must be ignored.\n          return;\n        }\n      }\n\n      if (dir === \"node_modules\") {\n        // Accept any file within a node_modules directory.\n        return installPath;\n      }\n    }\n\n    return installPath;\n  }\n\n  _splitPath(path) {\n    const partsInReverse = [];\n    for (let dir; (dir = pathDirname(path)) !== path; path = dir) {\n      partsInReverse.push(pathBasename(path));\n    }\n    return partsInReverse.reverse();\n  }\n\n  // Called by this.resolver when a module identifier cannot be resolved.\n  _onMissing(parentFile, id, forDynamicImport = false) {\n    const isApp = ! this.name;\n    const absParentPath = pathJoin(\n      this.sourceRoot,\n      parentFile.sourcePath,\n    );\n\n    if (isApp &&\n        Resolver.isNative(id) &&\n        this.isWeb()) {\n      // To ensure the native module can be evaluated at runtime, register\n      // a dependency on meteor-node-stubs/deps/<id>.js.\n      const stubId = Resolver.getNativeStubId(id);\n      if (isString(stubId) && stubId !== id) {\n        const info = parentFile.deps[id];\n\n        // Although not explicitly imported, any stubs associated with\n        // this native import should be recorded as implicit \"helpers.\"\n        info.helpers = info.helpers || {};\n        info.helpers[stubId] = forDynamicImport;\n\n        return this._resolve(parentFile, stubId, forDynamicImport);\n      }\n    }\n\n    const info = {\n      packageName: this.name,\n      parentPath: absParentPath,\n      bundleArch: this.bundleArch,\n      possiblySpurious: false,\n      dynamic: false,\n      // When we later attempt to resolve this id in the application's\n      // node_modules directory or in other packages, we need to remember\n      // if the parent module was imported dynamically, since that makes\n      // this import effectively dynamic, even if the parent module\n      // imported the given id with a static import or require.\n      parentWasDynamic: forDynamicImport,\n    };\n\n    if (parentFile &&\n        parentFile.deps &&\n        has(parentFile.deps, id)) {\n      const importInfo = parentFile.deps[id];\n      info.possiblySpurious = importInfo.possiblySpurious;\n      // Remember that this property only indicates whether or not the\n      // parent module used a dynamic import(...) to import this module.\n      // Even if info.dynamic is false (because the parent module used a\n      // static import or require for this import), this module may still\n      // be effectively dynamic if the parent was imported dynamically, as\n      // indicated by info.parentWasDynamic.\n      info.dynamic = importInfo.dynamic;\n    }\n\n    // If the imported identifier is neither absolute nor relative, but\n    // top-level, then it might be satisfied by a package installed in\n    // the top-level node_modules directory, and we should record the\n    // missing dependency so that we can include it in the app bundle.\n    if (parentFile) {\n      const missing =\n        parentFile.missingModules ||\n        Object.create(null);\n      missing[id] = info;\n      parentFile.missingModules = missing;\n    }\n\n    ImportScanner.mergeMissing(\n      this.allMissingModules,\n      { [id]: [info] }\n    );\n  }\n\n  _addPkgJsonToOutput(pkgJsonPath, pkg, forDynamicImport = false) {\n    const file = this._getFile(pkgJsonPath);\n\n    if (file) {\n      // If the file already exists, just update file.imported according\n      // to the forDynamicImport parameter.\n      file.imported = forDynamicImport\n        ? file.imported || \"dynamic\"\n        : true;\n\n      return file;\n    }\n\n    const data = Buffer.from(map(pkg, (value, key) => {\n      const isIdentifier = /^[_$a-zA-Z]\\w*$/.test(key);\n      const prop = isIdentifier\n        ? \".\" + key\n        : \"[\" + JSON.stringify(key) + \"]\";\n      return `exports${prop} = ${JSON.stringify(value)};\\n`;\n    }).join(\"\"));\n\n    const relPkgJsonPath = pathRelative(this.sourceRoot, pkgJsonPath);\n\n    const pkgFile = {\n      type: \"js\", // We represent the JSON module with JS.\n      data,\n      jsonData: pkg,\n      deps: {}, // Avoid accidentally re-scanning this file.\n      sourcePath: relPkgJsonPath,\n      installPath: this._getInstallPath(pkgJsonPath),\n      servePath: relPkgJsonPath,\n      hash: sha1(data),\n      lazy: true,\n      imported: forDynamicImport ? \"dynamic\" : true,\n      // Since _addPkgJsonToOutput is only ever called for package.json\n      // files that are involved in resolving package directories, and pkg\n      // is only a subset of the information in the actual package.json\n      // module, we mark it as imported implicitly, so that the subset can\n      // be overridden by the actual module if this package.json file is\n      // imported explicitly elsewhere.\n      implicit: true,\n    };\n\n    this._addFile(pkgJsonPath, pkgFile);\n\n    const hash = optimisticHashOrNull(pkgJsonPath);\n    if (hash) {\n      this.watchSet.addFile(pkgJsonPath, hash);\n    }\n\n    return pkgFile;\n  }\n}\n\neach([\"_readFile\", \"_findImportedModuleIdentifiers\",\n      \"_getInstallPath\"], funcName => {\n  ImportScanner.prototype[funcName] = Profile(\n    `ImportScanner#${funcName}`, ImportScanner.prototype[funcName]);\n});\n"]}