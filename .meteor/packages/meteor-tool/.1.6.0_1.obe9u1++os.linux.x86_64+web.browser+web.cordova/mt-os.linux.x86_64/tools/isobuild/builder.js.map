{"version":3,"sources":["/tools/isobuild/builder.js"],"names":["module","export","default","Builder","assert","watch","require","v","WatchSet","readAndWatchFile","sha1","files","NpmDiscards","Profile","optimisticReadFile","optimisticReaddir","optimisticStatOrNull","optimisticLStatOrNull","ENABLE_IN_PLACE_BUILDER_REPLACEMENT","process","platform","env","METEOR_DISABLE_BUILDER_IN_PLACE","constructor","outputPath","previousBuilder","usedAsFile","previousUsedAsFile","writtenHashes","previousWrittenHashes","nonce","Math","floor","random","buildPath","pathJoin","pathDirname","pathBasename","resetBuildPath","Error","exists","rm_recursive","mkdir_p","watchSet","_ensureDirectory","relPath","parts","pathNormalize","split","pathSep","length","pop","partsSoFar","forEach","part","push","partial","join","needToMkdir","unlink","_sanitize","isDirectory","partsOut","i","shouldBeFile","mustBeUnique","match","replace","ext","suffix","candidate","write","data","file","hash","sanitize","executable","symlink","slice","getData","Buffer","pathResolve","absPath","symlinkWithOverwrite","atomicallyRewriteFile","mode","writeJson","from","JSON","stringify","reserve","directory","soFar","shouldBeDirectory","generateFilename","writeToGeneratedFilename","writeOptions","generated","copyDirectory","to","ignore","specificFiles","npmDiscards","filter","absPathTo","specificPaths","f","walk","absFrom","relTo","_currentRealRootDir","absTo","item","thisAbsFrom","thisRelTo","cachedExternalPath","getExternalPath","real","realpath","e","code","isExternal","pathRelative","startsWith","fileStatus","isSymbolicLink","externalPath","itemForMatch","some","pattern","shouldDiscard","linkSource","readlink","linkTarget","symlinkIfPossible","isFile","writeFile","enter","methods","subBuilder","relPathWithSep","method","args","ret","substr","passThroughMethods","complete","removed","paths","Object","keys","path","hasOwnProperty","anotherPath","renameDirAlmostAtomically","abort","getWatchSet","options","rname","rpath","rename","source","target","slowBuilderMethods","prototype"],"mappings":"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","file":"tools/isobuild/builder.js.map","sourcesContent":["import assert from \"assert\";\nimport {WatchSet, readAndWatchFile, sha1} from '../fs/watch.js';\nimport files from '../fs/files.js';\nimport NpmDiscards from './npm-discards.js';\nimport {Profile} from '../tool-env/profile.js';\nimport {\n  optimisticReadFile,\n  optimisticReaddir,\n  optimisticStatOrNull,\n  optimisticLStatOrNull,\n} from \"../fs/optimistic.js\";\n\n// Builder is in charge of writing \"bundles\" to disk, which are\n// directory trees such as site archives, programs, and packages.  In\n// addition to writing data to files, it can copy or link in existing\n// files and directories (keeping track of them in a WatchSet in order\n// to trigger rebuilds appropriately).\n//\n// By default, Builder constructs the entire output directory from\n// scratch under a temporary name, and then moves it into place.\n// For efficient rebuilds, Builder can be given a `previousBuilder`,\n// in which case it will write files into the existing output directory\n// instead.\n//\n// On Windows (or when METEOR_DISABLE_BUILDER_IN_PLACE is set), Builder\n// always creates a new output directory under a temporary name rather than\n// using the old directory.  The reason is that we don't want rebuilding to\n// interfere with the running app, and we rely on the fact that on OS X and\n// Linux, if the process has opened a file for reading, it retains the file\n// by its inode, not path, so it is safe to write a new file to the same path\n// (or delete the file).\n//\n// Separate from that, Builder has a strategy of writing files under a temporary\n// name and then renaming them.  This is to achieve an \"atomic\" write, meaning\n// the server doesn't see a partially-written file that appears truncated.\n//\n// On Windows we copy files instead of symlinking them (see comments inline).\n\n\n// Whether to support writing files into the same directory as a previous\n// Builder on rebuild (rather than creating a new build directory and\n// moving it into place).\nconst ENABLE_IN_PLACE_BUILDER_REPLACEMENT =\n  (process.platform !== 'win32') &&\n  ! process.env.METEOR_DISABLE_BUILDER_IN_PLACE;\n\n\n// Options:\n//  - outputPath: Required. Path to the directory that will hold the\n//    bundle when building is complete. It should not exist (unless\n//    previousBuilder is passed). Its parents will be created if necessary.\n// - previousBuilder: Optional. An in-memory instance of Builder left\n// from the previous iteration. It is assumed that the previous builder\n// has completed its job successfully and its files are stored on the\n// file system in the exact layout as described in its usedAsFile data\n// structure; and the hashes of the contents correspond to the\n// writtenHashes data strcture.\nexport default class Builder {\n  constructor({outputPath, previousBuilder}) {\n    this.outputPath = outputPath;\n\n    // Paths already written to. Map from canonicalized relPath (no\n    // trailing slash) to true for a file, or false for a directory.\n    this.usedAsFile = { '': false, '.': false };\n    this.previousUsedAsFile = {};\n\n    this.writtenHashes = {};\n    this.previousWrittenHashes = {};\n\n    // foo/bar => foo/.build1234.bar\n    // Should we include a random number? The advantage is that multiple\n    // builds can run in parallel. The disadvantage is that stale build\n    // files hang around forever. For now, go with the former.\n    const nonce = Math.floor(Math.random() * 999999);\n    this.buildPath = files.pathJoin(files.pathDirname(this.outputPath),\n                                    '.build' + nonce + \".\" +\n                                    files.pathBasename(this.outputPath));\n\n    let resetBuildPath = true;\n\n    // If we have a previous builder and we are allowed to re-use it,\n    // let's keep all the older files on the file-system and replace\n    // only outdated ones + write the new files in the same path\n    if (previousBuilder && ENABLE_IN_PLACE_BUILDER_REPLACEMENT) {\n      if (previousBuilder.outputPath !== outputPath) {\n        throw new Error(\n          `previousBuilder option can only be set to a builder with the same output path.\nPrevious builder: ${previousBuilder.outputPath}, this builder: ${outputPath}`\n        );\n      }\n\n      if (files.exists(previousBuilder.outputPath)) {\n        // write files in-place in the output directory of the previous builder\n        this.buildPath = previousBuilder.outputPath;\n\n        this.previousWrittenHashes = previousBuilder.writtenHashes;\n        this.previousUsedAsFile = previousBuilder.usedAsFile;\n\n        resetBuildPath = false;\n      } else {\n        resetBuildPath = true;\n      }\n    }\n\n    // Build the output from scratch\n    if (resetBuildPath) {\n      files.rm_recursive(this.buildPath);\n      files.mkdir_p(this.buildPath, 0o755);\n    }\n\n    this.watchSet = new WatchSet();\n\n    // XXX cleaner error handling. don't make the humans read an\n    // exception (and, make suitable for use in automated systems)\n  }\n\n  // Like mkdir_p, but records in self.usedAsFile that we have created\n  // the directories, and takes a path relative to the bundle\n  // root. Throws an exception on failure.\n  _ensureDirectory(relPath) {\n    const parts = files.pathNormalize(relPath).split(files.pathSep);\n    if (parts.length > 1 && parts[parts.length - 1] === '') {\n      // remove trailing slash\n      parts.pop();\n    }\n\n    const partsSoFar = [];\n    parts.forEach(part => {\n      partsSoFar.push(part);\n      const partial = partsSoFar.join(files.pathSep);\n      if (! (partial in this.usedAsFile)) {\n        let needToMkdir = true;\n        if (partial in this.previousUsedAsFile) {\n          if (this.previousUsedAsFile[partial]) {\n            // was previously used as file, delete it, create a directory\n            files.unlink(partial);\n          } else {\n            // is already a directory\n            needToMkdir = false;\n          }\n        }\n\n        if (needToMkdir) {\n          // It's new -- create it\n          files.mkdir_p(files.pathJoin(this.buildPath, partial), 0o755);\n        }\n        this.usedAsFile[partial] = false;\n      } else if (this.usedAsFile[partial]) {\n        // Already exists and is a file. Oops.\n        throw new Error(`tried to make ${relPath} a directory but ${partial} is already a file`);\n      } else {\n        // Already exists and is a directory\n      }\n    });\n  }\n\n  // isDirectory defaults to false\n  _sanitize(relPath, isDirectory) {\n    const parts = relPath.split(files.pathSep);\n    const partsOut = [];\n    for (let i = 0; i < parts.length; i++) {\n      let part = parts[i];\n      const shouldBeFile = (i === parts.length - 1) && ! isDirectory;\n      const mustBeUnique = (i === parts.length - 1);\n\n      // Basic sanitization\n      if (part.match(/^\\.+$/)) {\n        throw new Error(`Path contains forbidden segment '${part}'`);\n      }\n\n      part = part.replace(/[^a-zA-Z0-9._\\:\\-@#]/g, '_');\n\n      // If at last component, pull extension (if any) off of part\n      let ext = '';\n      if (shouldBeFile) {\n        const split = part.split('.');\n        if (split.length > 1) {\n          ext = \".\" + split.pop();\n        }\n        part = split.join('.');\n      }\n\n      // Make sure it's sufficiently unique\n      let suffix = '';\n      while (true) {\n        const candidate = files.pathJoin(partsOut.join(files.pathSep), part + suffix + ext);\n        if (candidate.length) {\n          // If we've never heard of this, then it's unique enough.\n          if (!(candidate in this.usedAsFile)) {\n            break;\n          }\n          // If we want this bit to be a directory, and we don't need it to be\n          // unique (ie, it isn't the very last bit), and it's currently a\n          // directory, then that's OK.\n          if (!(mustBeUnique || this.usedAsFile[candidate])) {\n            break;\n          }\n          // OK, either we want it to be unique and it already exists; or it is\n          // currently a file (and we want it to be either a different file or a\n          // directory).  Try a new suffix.\n        }\n\n        suffix++; // first increment will do '' -> 1\n      }\n\n      partsOut.push(part + suffix + ext);\n    }\n\n    return partsOut.join(files.pathSep);\n  }\n\n  // Write either a buffer or the contents of a file to `relPath` (a\n  // path to a file relative to the bundle root), creating it (and any\n  // enclosing directories) if it doesn't exist yet. Exactly one of\n  // `data` and or `file` must be passed.\n  //\n  // Options:\n  // - data: a Buffer to write to relPath. Overrides `file`.\n  // - file: a filename to write to relPath, as a string.\n  // - sanitize: if true, then all components of the path are stripped\n  //   of any potentially troubling characters, an exception is thrown\n  //   if any path segments consist entirely of dots (eg, '..'), and\n  //   if there is a file in the bundle with the same relPath, then\n  //   the path is changed by adding a numeric suffix.\n  // - hash: a sha1 string used to determine if the contents of the\n  //   new file written is not cached.\n  // - executable: if true, mark the file as executable.\n  // - symlink: if set to a string, create a symlink to its value\n  //\n  // Returns the final canonicalize relPath that was written to.\n  //\n  // If `file` is used then it will be added to the builder's WatchSet.\n  write(relPath, {data, file, hash, sanitize, executable, symlink}) {\n    // Ensure no trailing slash\n    if (relPath.slice(-1) === files.pathSep) {\n      relPath = relPath.slice(0, -1);\n    }\n\n    // In sanitize mode, ensure path does not contain segments like\n    // '..', does not contain forbidden characters, and is unique.\n    if (sanitize) {\n      relPath = this._sanitize(relPath);\n    }\n\n    let getData = null;\n    if (data) {\n      if (! (data instanceof Buffer)) {\n        throw new Error(\"data must be a Buffer\");\n      }\n      if (file) {\n        throw new Error(\"May only pass one of data and file, not both\");\n      }\n      getData = () => data;\n    } else if (file) {\n      // postpone reading the file into memory\n      getData = () => readAndWatchFile(this.watchSet, files.pathResolve(file));\n    } else if (! symlink) {\n      throw new Error('Builder can not write without either data or a file path or a symlink path: ' + relPath);\n    }\n\n    this._ensureDirectory(files.pathDirname(relPath));\n    const absPath = files.pathJoin(this.buildPath, relPath);\n\n    if (symlink) {\n      symlinkWithOverwrite(symlink, absPath);\n    } else {\n      hash = hash || sha1(getData());\n\n      if (this.previousWrittenHashes[relPath] !== hash) {\n        // Builder is used to create build products, which should be read-only;\n        // users shouldn't be manually editing automatically generated files and\n        // expecting the results to \"stick\".\n        atomicallyRewriteFile(absPath, getData(), {\n          mode: executable ? 0o555 : 0o444\n        });\n      }\n\n      this.writtenHashes[relPath] = hash;\n    }\n    this.usedAsFile[relPath] = true;\n\n    return relPath;\n  }\n\n  // Serialize `data` as JSON and write it to `relPath` (a path to a\n  // file relative to the bundle root), creating parent directories as\n  // necessary. Throw an exception if the file already exists.\n  writeJson(relPath, data) {\n    // Ensure no trailing slash\n    if (relPath.slice(-1) === files.pathSep) {\n      relPath = relPath.slice(0, -1);\n    }\n\n    this._ensureDirectory(files.pathDirname(relPath));\n    const absPath = files.pathJoin(this.buildPath, relPath);\n\n    atomicallyRewriteFile(\n      absPath,\n      Buffer.from(JSON.stringify(data, null, 2), 'utf8'),\n      {mode: 0o444});\n\n    this.usedAsFile[relPath] = true;\n  }\n\n  // Add relPath to the list of \"already taken\" paths in the\n  // bundle. This will cause write, when in sanitize mode, to never\n  // pick this filename (and will prevent files that from being\n  // written that would conflict with paths that we are expecting to\n  // be directories). Calling this twice on the same relPath will\n  // given an exception.\n  //\n  // Returns the *current* (temporary!) path to where the file or directory\n  // lives. This is so you could use non-builder code to write into a reserved\n  // directory.\n  //\n  // options:\n  // - directory: set to true to reserve this relPath to be a\n  //   directory rather than a file.\n  reserve(relPath, {directory} = {}) {\n    // Ensure no trailing slash\n    if (relPath.slice(-1) === files.pathSep) {\n      relPath = relPath.slice(0, -1);\n    }\n\n    const parts = relPath.split(files.pathSep);\n    const partsSoFar = [];\n    for (let i = 0; i < parts.length; i ++) {\n      const part = parts[i];\n      partsSoFar.push(part);\n      const soFar = partsSoFar.join(files.pathSep);\n      if (this.usedAsFile[soFar]) {\n        throw new Error(\"Path reservation conflict: \" + relPath);\n      }\n\n      const shouldBeDirectory = (i < parts.length - 1) || directory;\n      if (shouldBeDirectory) {\n        if (! (soFar in this.usedAsFile)) {\n          let needToMkdir = true;\n          if (soFar in this.previousUsedAsFile) {\n            if (this.previousUsedAsFile[soFar]) {\n              files.unlink(soFar);\n            } else {\n              needToMkdir = false;\n            }\n          }\n          if (needToMkdir) {\n            files.mkdir_p(files.pathJoin(this.buildPath, soFar), 0o755);\n          }\n          this.usedAsFile[soFar] = false;\n        }\n      } else {\n        this.usedAsFile[soFar] = true;\n      }\n    }\n\n    // Return the path we reserved.\n    return files.pathJoin(this.buildPath, relPath);\n  }\n\n  // Generate and reserve a unique name for a file based on `relPath`,\n  // and return it. If `relPath` is available (there is no file with\n  // that name currently existing or reserved, it doesn't contain\n  // forbidden characters, a prefix of it is not already in use as a\n  // file rather than a directory) then the return value will be\n  // `relPath`. Otherwise relPath will be modified to get the return\n  // value, say by adding a numeric suffix to some path components\n  // (preserving the file extension however) and deleting forbidden\n  // characters. Throws an exception if relPath contains any segments\n  // that are all dots (eg, '..').\n  //\n  // options:\n  //\n  // - directory: generate (and reserve) a name for a directory,\n  //   rather than a file.\n  generateFilename(relPath, {directory} = {}) {\n    relPath = this._sanitize(relPath, directory);\n    this.reserve(relPath, { directory });\n    return relPath;\n  }\n\n  // Convenience wrapper around generateFilename and write.\n  //\n  // (Note that in the object returned by builder.enter, this method\n  // is patched through directly rather than rewriting its inputs and\n  // outputs. This is only valid because it does nothing with its inputs\n  // and outputs other than send pass them to other methods.)\n  writeToGeneratedFilename(relPath, writeOptions) {\n    const generated = this.generateFilename(relPath);\n    this.write(generated, writeOptions);\n    return generated;\n  }\n\n  // Recursively copy a directory and all of its contents into the\n  // bundle. But if the symlink option was passed to the Builder\n  // constructor, then make a symlink instead, if possible.\n  //\n  // Unlike with files.cp_r, if a symlink is found, it is copied as a symlink.\n  //\n  // This does NOT add anything to the WatchSet.\n  //\n  // Options:\n  // - from: source path on local disk to copy from\n  // - to: relative path to a directory in the bundle that will\n  //   receive the files\n  // - ignore: array of regexps of filenames (that is, basenames) to\n  //   ignore (they may still be visible in the output bundle if\n  //   symlinks are being used).  Like with WatchSets, they match against\n  //   entries that end with a slash if it's a directory.\n  // - specificFiles: just copy these paths (specified as relative to 'to').\n  // - symlink: true if the directory should be symlinked instead of copying\n  copyDirectory({\n    from, to,\n    ignore,\n    specificFiles,\n    symlink,\n    npmDiscards,\n    // Optional predicate to filter files and directories.\n    filter,\n  }) {\n    if (to.slice(-1) === files.pathSep) {\n      to = to.slice(0, -1);\n    }\n\n    const absPathTo = files.pathJoin(this.buildPath, to);\n\n    if (symlink) {\n      if (specificFiles) {\n        throw new Error(\"can't copy only specific paths with a single symlink\");\n      }\n\n      if (this.usedAsFile[to]) {\n        throw new Error(\"tried to copy a directory onto \" + to +\n                        \" but it is is already a file\");\n      }\n    }\n\n    ignore = ignore || [];\n    let specificPaths = null;\n    if (specificFiles) {\n      specificPaths = {};\n      specificFiles.forEach(f => {\n        while (f !== '.') {\n          specificPaths[files.pathJoin(to, f)] = true;\n          f = files.pathDirname(f);\n        }\n      });\n    }\n\n    const walk = (\n      absFrom,\n      relTo,\n      _currentRealRootDir = absFrom\n    ) => {\n      if (symlink && ! (relTo in this.usedAsFile)) {\n        this._ensureDirectory(files.pathDirname(relTo));\n        const absTo = files.pathResolve(this.buildPath, relTo);\n        symlinkWithOverwrite(absFrom, absTo);\n        return;\n      }\n\n      this._ensureDirectory(relTo);\n\n      optimisticReaddir(absFrom).forEach(item => {\n        let thisAbsFrom = files.pathResolve(absFrom, item);\n        const thisRelTo = files.pathJoin(relTo, item);\n\n        if (specificPaths && !(thisRelTo in specificPaths)) {\n          return;\n        }\n\n        // Returns files.realpath(thisAbsFrom), iff it is external to\n        // _currentRealRootDir, using caching because this function might\n        // be called more than once.\n        let cachedExternalPath;\n        const getExternalPath = () => {\n          if (typeof cachedExternalPath !== \"undefined\") {\n            return cachedExternalPath;\n          }\n\n          try {\n            var real = files.realpath(thisAbsFrom);\n          } catch (e) {\n            if (e.code !== \"ENOENT\" &&\n                e.code !== \"ELOOP\") {\n              throw e;\n            }\n            return cachedExternalPath = false;\n          }\n\n          const isExternal =\n            files.pathRelative(_currentRealRootDir, real).startsWith(\"..\");\n\n          // Now cachedExternalPath is either a string or false.\n          return cachedExternalPath = isExternal && real;\n        };\n\n        let fileStatus = optimisticLStatOrNull(thisAbsFrom);\n\n        if (! symlink &&\n            fileStatus &&\n            fileStatus.isSymbolicLink()) {\n          // If copyDirectory is not allowed to create symbolic links to\n          // external files, and this file is a symbolic link that points\n          // to an external file, update fileStatus so that we copy this\n          // file as a normal file rather than as a symbolic link.\n\n          const externalPath = getExternalPath();\n          if (externalPath) {\n            // Copy from the real path rather than the link path.\n            thisAbsFrom = externalPath;\n\n            // Update fileStatus to match the actual file rather than the\n            // symbolic link, thus forcing the file to be copied below.\n            fileStatus = optimisticLStatOrNull(externalPath);\n\n            if (fileStatus && fileStatus.isDirectory()) {\n              // Update _currentRealRootDir so that we can judge\n              // isExternal relative to this new root directory when\n              // traversing nested directories.\n              _currentRealRootDir = externalPath;\n            }\n          }\n        }\n\n        if (! fileStatus) {\n          // If the file did not exist, skip it.\n          return;\n        }\n\n        let itemForMatch = item;\n        const isDirectory = fileStatus.isDirectory();\n        if (isDirectory) {\n          itemForMatch += '/';\n        }\n\n        // skip excluded files\n        if (ignore.some(pattern => itemForMatch.match(pattern))) {\n          return;\n        }\n\n        if (typeof filter === \"function\" &&\n            ! filter(thisAbsFrom, isDirectory)) {\n          return;\n        }\n\n        if (npmDiscards instanceof NpmDiscards &&\n            npmDiscards.shouldDiscard(thisAbsFrom, isDirectory)) {\n          return;\n        }\n\n        if (isDirectory) {\n          walk(thisAbsFrom, thisRelTo, _currentRealRootDir);\n          return;\n        }\n\n        if (fileStatus.isSymbolicLink()) {\n          // Symbolic links pointing to relative external paths are less\n          // portable than absolute links, so getExternalPath() is\n          // preferred if it returns a path.\n          const linkSource = getExternalPath() ||\n            files.readlink(thisAbsFrom);\n\n          const linkTarget =\n            files.pathResolve(this.buildPath, thisRelTo);\n\n          if (symlinkIfPossible(linkSource, linkTarget)) {\n            // A symlink counts as a file, as far as \"can you put\n            // something under it\" goes.\n            this.usedAsFile[thisRelTo] = true;\n            return;\n          }\n        }\n\n        // Fall back to copying the file, but make sure it's really a file\n        // first, just in case it was a symbolic link to a directory that\n        // could not be created above.\n        fileStatus = optimisticStatOrNull(thisAbsFrom);\n        if (fileStatus && fileStatus.isFile()) {\n          // XXX can't really optimize this copying without reading\n          // the file into memory to calculate the hash.\n          files.writeFile(\n            files.pathResolve(this.buildPath, thisRelTo),\n            // The reason we call files.writeFile here instead of\n            // files.copyFile is so that we can read the file using\n            // optimisticReadFile instead of files.createReadStream.\n            optimisticReadFile(thisAbsFrom),\n            // Logic borrowed from files.copyFile: \"Create the file as\n            // readable and writable by everyone, and executable by everyone\n            // if the original file is executably by owner. (This mode will be\n            // modified by umask.) We don't copy the mode *directly* because\n            // this function is used by 'meteor create' which is copying from\n            // the read-only tools tree into a writable app.\"\n            { mode: (fileStatus.mode & 0o100) ? 0o777 : 0o666 },\n          );\n\n          this.usedAsFile[thisRelTo] = true;\n        }\n      });\n    };\n\n    walk(files.realpath(from), to);\n  }\n\n  // Returns a new Builder-compatible object that works just like a\n  // Builder, but interprets all paths relative to 'relPath', a path\n  // relative to the bundle root which should not start with a '/'.\n  //\n  // The sub-builder returned does not have all Builder methods (for\n  // example, complete() wouldn't make sense) and you should not rely\n  // on it being instanceof Builder.\n  enter(relPath) {\n    const methods = [\"write\", \"writeJson\", \"reserve\", \"generateFilename\",\n                   \"copyDirectory\", \"enter\"];\n    const subBuilder = {};\n    const relPathWithSep = relPath + files.pathSep;\n\n    methods.forEach(method => {\n      subBuilder[method] = (...args) => {\n        if (method !== \"copyDirectory\") {\n          // Normal method (relPath as first argument)\n          args[0] = files.pathJoin(relPath, args[0]);\n        } else {\n          // with copyDirectory the path we have to fix up is inside\n          // an options hash\n          args[0].to = files.pathJoin(relPath, args[0].to);\n        }\n\n        let ret = this[method](...args);\n\n        if (method === \"generateFilename\") {\n          // fix up the returned path to be relative to the\n          // sub-bundle, not the parent bundle\n          if (ret.substr(0, 1) === '/') {\n            ret = ret.substr(1);\n          }\n          if (ret.substr(0, relPathWithSep.length) !== relPathWithSep) {\n            throw new Error(\"generateFilename returned path outside of \" +\n                            \"sub-bundle?\");\n          }\n          ret = ret.substr(relPathWithSep.length);\n        }\n\n        return ret;\n      };\n    });\n\n    // Methods that don't have to fix up arguments or return values, because\n    // they are implemented purely in terms of other methods which do.\n    const passThroughMethods = [\"writeToGeneratedFilename\"];\n    passThroughMethods.forEach(method => {\n      subBuilder[method] = this[method];\n    });\n\n    return subBuilder;\n  }\n\n  // Move the completed bundle into its final location (outputPath)\n  complete() {\n    if (this.previousUsedAsFile) {\n      // delete files and folders left-over from previous runs and not\n      // re-used in this run\n      const removed = {};\n      const paths = Object.keys(this.previousUsedAsFile);\n      paths.forEach((path) => {\n        // if the same path was re-used, leave it\n        if (this.usedAsFile.hasOwnProperty(path)) { return; }\n\n        // otherwise, remove it as it is no longer needed\n\n        // skip if already deleted\n        if (removed.hasOwnProperty(path)) { return; }\n\n        const absPath = files.pathJoin(this.buildPath, path);\n        if (this.previousUsedAsFile[path]) {\n          // file\n          files.unlink(absPath);\n          removed[path] = true;\n        } else {\n          // directory\n          files.rm_recursive(absPath);\n\n          // mark all sub-paths as removed, too\n          paths.forEach((anotherPath) => {\n            if (anotherPath.startsWith(path + '/')) {\n              removed[anotherPath] = true;\n            }\n          });\n        }\n      });\n    }\n\n    // XXX Alternatively, we could just keep buildPath around, and make\n    // outputPath be a symlink pointing to it. This doesn't work for the NPM use\n    // case of renameDirAlmostAtomically since that one is constructing files to\n    // be checked in to version control, but here we could get away with it.\n    if (this.buildPath !== this.outputPath) {\n      files.renameDirAlmostAtomically(this.buildPath, this.outputPath);\n    }\n  }\n\n  // Delete the partially-completed bundle. Do not disturb outputPath.\n  abort() {\n    files.rm_recursive(this.buildPath);\n  }\n\n  // Returns a WatchSet representing all files that were read from disk by the\n  // builder.\n  getWatchSet() {\n    return this.watchSet;\n  }\n}\n\nfunction atomicallyRewriteFile(path, data, options) {\n  // create a different file with a random name and then rename over atomically\n  const rname = '.builder-tmp-file.' + Math.floor(Math.random() * 999999);\n  const rpath = files.pathJoin(files.pathDirname(path), rname);\n  files.writeFile(rpath, data, options);\n  try {\n    files.rename(rpath, path);\n  } catch (e) {\n    if (e.code === 'EISDIR') {\n      // replacing a directory with a file; this is rare (so it can\n      // be a slow path) but can legitimately happen if e.g. a developer\n      // puts a file where there used to be a directory in their app.\n      files.rm_recursive(path);\n      files.rename(rpath, path);\n    } else {\n      throw e;\n    }\n  }\n}\n\nfunction symlinkIfPossible(source, target) {\n  try {\n    symlinkWithOverwrite(source, target);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n// create a symlink, overwriting the target link, file, or directory\n// if it exists\nfunction symlinkWithOverwrite(source, target) {\n  try {\n    files.symlink(source, target);\n  } catch (e) {\n    if (e.code === \"EEXIST\") {\n      // overwrite existing link, file, or directory\n      files.rm_recursive(target);\n      files.symlink(source, target);\n    } else if (e.code === \"EPERM\" &&\n               process.platform === \"win32\") {\n      files.rm_recursive(target);\n      // This will work only if source refers to a directory, but that's a\n      // chance worth taking.\n      files.symlink(source, target, \"junction\");\n    } else {\n      throw e;\n    }\n  }\n}\n\n// Wrap slow methods into Profiler calls\nconst slowBuilderMethods = [\n  '_ensureDirectory', 'write', 'enter', 'copyDirectory', 'enter', 'complete'\n];\n\nslowBuilderMethods.forEach(method => {\n  Builder.prototype[method] =\n    Profile(`Builder#${method}`, Builder.prototype[method]);\n});\n"]}