{"version":3,"sources":["/tools/packaging/package-client.js"],"names":["module1","module","export","bundleBuild","createAndPublishBuiltPackage","requestGarbageCollection","watch","require","v","_","config","httpHelpers","release","files","utils","buildmessage","compiler","authClient","catalog","projectContextModule","colonConverter","Profile","openPackageServerConnection","packageServerUrl","serverUrl","getPackageServerUrl","openServiceConnection","generateBlankReadme","contents","excerpt","hash","blankHash","saveReadmeToTmp","readmeInfo","tempReadmeDir","mkdtemp","readmePath","pathJoin","writeFileAtomically","exports","callPackageServer","conn","args","connected","close","loggedInPackagesConnection","call","callPackageServerBM","assertInJob","apply","e","error","reason","message","loadRemotePackageData","syncToken","options","syncOpts","useShortPages","shortPagesForTest","compressCollections","updateServerPackageData","dataStore","enterJob","_updateServerPackageData","self","Error","done","ret","resetData","useProgressbar","start","undefined","state","current","end","reportProgress","getSomeData","getSyncToken","format","builds","versions","Date","now","compress","process","env","METEOR_CATALOG_COMPRESS_RPCS","remoteData","reset","collectionsCompressed","zlib","colsGzippedBuffer","Buffer","from","colsJSON","Promise","resolve","reject","gunzip","err","res","await","collections","JSON","parse","syncComplete","isEqual","upToDate","insertData","loggedInConnection","getPackageServerDomain","bundleSource","isopack","includeSources","packageDir","name","tempDir","packageTarName","version","dirToTar","convert","sourcePackageDir","mkdir_p","each","f","to","exists","copyFile","packageMapFilename","pluginProviderPackageMap","packageMapFile","PackageMapFile","filename","write","sourceTarball","createTarball","tarballHash","fileHash","treeHash","uploadFile","putUrl","filepath","size","stat","rs","createReadStream","getUrl","method","url","headers","bodyStream","bodyStreamLength","toString","isopackCache","tarballName","tarInputDir","saveToPath","includePreCompilerPluginIsopackVersions","buildTarball","ignore","relativePath","pieces","split","pathSep","length","last","contains","createBuiltPackage","bundleResult","jobHasMessages","publishBuiltPackage","uploadInfo","packageName","buildArchitectures","uploadUrl","uploadToken","handlePackageServerConnectionError","handleConnectionError","updatePackageMetadata","packageSource","connection","dataToUpdate","git","metadata","description","summary","longDescription","versionIdentifier","publishPackage","projectContext","new","existingVersion","validatePackageName","useBuildmessage","packRecord","official","getPackage","amIAuthorized","processReadme","packageDeps","getDependencyMetadata","refs","label","constraint","isCore","inCheckout","localCatalog","versionString","getLatestVersion","getIsopack","canWriteLegacyBuilds","has","references","arch","sourceFiles","getSourceFilesUnderSourceRoot","sourceRoot","testName","testIsopack","testSourceFiles","union","sourceBundleResult","existingRecord","getVersion","source","doNotPublishBuild","uploadRec","compilerVersion","BUILT_BY","containsPlugins","debugOnly","prodOnly","testOnly","getExports","releaseName","dependencies","readmeUrl","hashes","readmeHash","isRelease","methodName"],"mappings":"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","file":"tools/packaging/package-client.js.map","sourcesContent":["var _ = require('underscore');\n\nvar config = require('../meteor-services/config.js');\nvar httpHelpers = require('../utils/http-helpers.js');\nvar release = require('./release.js');\nvar files = require('../fs/files.js');\nvar utils = require('../utils/utils.js');\nvar buildmessage = require('../utils/buildmessage.js');\nvar compiler = require('../isobuild/compiler.js');\nvar authClient = require('../meteor-services/auth-client.js');\nvar catalog = require('./catalog/catalog.js');\nvar projectContextModule = require('../project-context.js');\nvar colonConverter = require('../utils/colon-converter.js');\nvar Profile = require('../tool-env/profile.js').Profile;\n\nimport { requestGarbageCollection } from \"../utils/gc.js\";\n\n// Opens a DDP connection to a package server. Loads the packages needed for a\n// DDP connection, then calls DDP connect to the package server URL in config,\n// using a current user-agent header composed by http-helpers.js.\nvar openPackageServerConnection = function (packageServerUrl) {\n  var serverUrl = packageServerUrl || config.getPackageServerUrl();\n  return authClient.openServiceConnection(serverUrl);\n};\n\n// We don't let the user upload a blank README for UX reasons, but we would\n// prefer that the server move to a world with 'readme' files for everything in\n// the future. As a way to breach these interfaces, for now, we are going to\n// upload blank documentation files when null docs are requested.\n//\n// This function generates a Readme object for a blank readme file, as well as\n// the file itself.\nvar generateBlankReadme = function () {\n  return {\n    contents: \"\",\n    excerpt: \"\",\n    hash: files.blankHash\n  };\n};\n\n// Save a readme file to a temporary path.\nvar saveReadmeToTmp = function (readmeInfo) {\n  var tempReadmeDir = files.mkdtemp('readme');\n  var readmePath = files.pathJoin(tempReadmeDir, \"Readme.md\");\n  files.writeFileAtomically(readmePath, readmeInfo.contents);\n  return readmePath;\n};\n\n// Given a connection, makes a call to the package server.  (Checks to see if\n// the connection is connected, and reconnects if needed -- a workaround for\n// the fact that connections in the tool do not reconnect)\nexports.callPackageServer = function (conn, ...args) {\n  // XXX This is broken since it doesn't actually replace the conn in the\n  // caller, so it'll happen on every subsequent call\n  if (!conn.connected) {\n    conn.close();\n    conn = exports.loggedInPackagesConnection();\n  }\n  return conn.call(...args);\n};\n\nvar callPackageServerBM = exports.callPackageServerBM = function (...args) {\n  buildmessage.assertInJob();\n  try {\n    return exports.callPackageServer.apply(null, args);\n  } catch (e) {\n    buildmessage.error(e.reason || e.message);\n    return null;\n  }\n};\n\n// Requests and returns one page of new package data that we haven't cached on\n// disk. We assume that data is cached chronologically, so essentially, we are\n// asking for a diff from the last time that we did this.\n// Takes in:\n// - conn: the connection to use (does not have to be logged in)\n// - syncToken: a syncToken object to be sent to the server that\n//   represents the last time that we talked to the server.\n// - options:\n//    - useShortPages (Boolean). Ask the server for pages of ~3 records\n//      instead of ~100, for testing pagination.\n//\n// Returns an object, containing the following fields:\n//  - syncToken: a new syncToken object, that we can pass to the server in the future.\n//  - collections: an object keyed by the name of server collections, with the\n//    records as an array of javascript objects.\nvar loadRemotePackageData = function (conn, syncToken, options) {\n  options = options || {};\n\n  // Did we get disconnected between retries somehow? Then we should open a new\n  // connection. We shouldn't use the callPackageServer method here though,\n  // since we don't need to authenticate.\n  if (!conn.connected) {\n    conn.close();\n    conn =  openPackageServerConnection();\n  }\n\n  var syncOpts = {};\n  if (options && options.useShortPages) {\n    syncOpts.shortPagesForTest = options.useShortPages;\n  }\n  if (options && options.compressCollections) {\n    syncOpts.compressCollections = options.compressCollections;\n  }\n  return conn.call('syncNewPackageData', syncToken, syncOpts);\n};\n\n// Contacts the package server to get the latest diff and writes changes to\n// disk.\n//\n// Takes in the dataStore, which is an example of the remote catalog. Contacts\n// the package server and updates the sql database with the most recent\n// information.\n//\n// Returns null if contacting the server times out, or an object with the\n// following keys:\n//     resetData : true if we should reset the database, otherwise false.\n//     connectionFailed: true if we failed to connect to the server.\n//\n// options can include:\n//  - packageStorageFile: String. The file to write the data to (overrides\n//    `config.getPackageStorage()`)\n//  - packageServerUrl: String. The package server (overrides\n//    `config.getPackageServerUrl()`)\n//  - useShortPages: Boolean. Request short pages of ~3 records from the\n//    server, instead of ~100 that it would send otherwise\nexports.updateServerPackageData = function (dataStore, options) {\n  return buildmessage.enterJob('updating package catalog', function () {\n    return _updateServerPackageData(dataStore, options);\n  });\n};\n\nvar _updateServerPackageData = function (dataStore, options) {\n  var self = this;\n  options = options || {};\n  if (dataStore === null) {\n    throw Error(\"Data store expected\");\n  }\n\n  var done = false;\n  var ret = {resetData: false};\n\n  // For now, we don't have a great progress metric, so just use a spinner\n  var useProgressbar = false;\n\n  var start = undefined;\n  // Guess that we're about an hour behind, as an opening guess\n  var state = { current: 0, end: 60 * 60 * 1000, done: false};\n  useProgressbar && buildmessage.reportProgress(state);\n\n  var conn = openPackageServerConnection(options.packageServerUrl);\n\n  // Provide some progress indication for connection\n  // XXX though it is just a hack\n  state.current = 1;\n  useProgressbar && buildmessage.reportProgress(state);\n\n  var getSomeData = function () {\n    var syncToken = dataStore.getSyncToken() || {format: \"1.1\"};\n\n    if (!start) {\n      start = {};\n      start.builds = syncToken.builds;\n      start.versions = syncToken.versions;\n      state.end = (Date.now() - start.builds) + (Date.now() - start.versions);\n    }\n    // XXX: This is a hack... syncToken should have a % done\n    state.current =\n      (syncToken.builds - start.builds) +\n      (syncToken.versions - start.versions);\n    useProgressbar && buildmessage.reportProgress(state);\n\n    var compress = !!process.env.METEOR_CATALOG_COMPRESS_RPCS;\n\n    // (loadRemotePackageData may throw)\n    var remoteData = loadRemotePackageData(conn, syncToken, {\n      useShortPages: options.useShortPages,\n      compressCollections: compress\n    });\n\n    // Is the remote server telling us to ignore everything we've heard before?\n    // OK, we can do that.\n    if (remoteData.resetData) {\n      dataStore.reset();\n      // The caller may want to take this as a cue to delete packages from the\n      // tropohouse.\n      ret.resetData = true;\n    }\n\n    if (remoteData.collectionsCompressed) {\n      var zlib = require('zlib');\n      var colsGzippedBuffer = Buffer.from(\n        remoteData.collectionsCompressed, 'base64');\n      var colsJSON = new Promise((resolve, reject) => {\n        zlib.gunzip(colsGzippedBuffer, (err, res) => {\n          err ? reject(err) : resolve(res);\n        });\n      }).await();\n      remoteData.collections = JSON.parse(colsJSON);\n      delete remoteData.collectionsCompressed;\n    }\n\n    // We always write to the data store; the fact there is no data is itself\n    // data!  e.g. the last-refresh timestamp\n    var syncComplete =\n          _.isEqual(remoteData.collections, {}) || remoteData.upToDate;\n    dataStore.insertData(remoteData, syncComplete);\n\n    // If there is no new data from the server, don't bother writing things to\n    // disk (unless we were just told to reset everything).\n    if (!remoteData.resetData && _.isEqual(remoteData.collections, {})) {\n      done = true;\n      return;\n    }\n\n    if (remoteData.upToDate) {\n      done = true;\n    }\n  };\n\n  try {\n    while (!done) {\n      getSomeData();\n      requestGarbageCollection();\n    }\n  } finally {\n    conn.close();\n  }\n\n  return ret;\n};\n\n_updateServerPackageData = Profile('package-client _updateServerPackageData',\n                                   _updateServerPackageData);\n\n// Returns a logged-in DDP connection to the package server, or null if\n// we cannot log in. If an error unrelated to login occurs\n// (e.g. connection to package server times out), then it will be\n// thrown.\nexports.loggedInPackagesConnection = function () {\n  return authClient.loggedInConnection(\n    config.getPackageServerUrl(),\n    config.getPackageServerDomain(),\n    \"package-server\"\n  );\n};\n\n// XXX this is missing a few things. In retrospect a better approach here might\n//     be to actually make \"save source somewhere else\" or perhaps \"add source\n//     to tarball\" be part of the package build itself...\nvar bundleSource = function (isopack, includeSources, packageDir) {\n  buildmessage.assertInJob();\n\n  var name = isopack.name;\n\n  var tempDir = files.mkdtemp('build-source-package-');\n  var packageTarName = name + '-' + isopack.version + '-source';\n  var dirToTar = files.pathJoin(tempDir, 'source',\n    colonConverter.convert(packageTarName));\n  // XXX name probably needs to be escaped for windows?\n  // XXX note that publish-for-arch thinks it knows how this tarball is laid\n  //     out, which is a bit of a shame\n  var sourcePackageDir = files.pathJoin(dirToTar, colonConverter.convert(name));\n  if (! files.mkdir_p(sourcePackageDir)) {\n    buildmessage.error('Failed to create temporary source directory: ' +\n                       sourcePackageDir);\n    return null;\n  }\n\n  // We copy source files into a temp directory and then tar up the temp\n  // directory. It would be great if we could avoid the copy, but as far\n  // as we can tell, this is the only way to get a tarball with the\n  // directory structure that we want (<package name>-<version-source/\n  // at the top level).\n  _.each(includeSources, function (f) {\n    const from = files.pathJoin(packageDir, f);\n    const to = files.pathJoin(sourcePackageDir, f);\n    if (files.exists(from)) {\n      files.copyFile(from, to);\n    }\n  });\n\n  // Write a package map to `.versions` inside the source tarball.  Note that\n  // this differs in two ways from the `.versions` file that is maintained\n  // inside standalone packages by 'meteor publish':\n  //  (a) It only contains the direct, directly implied, and linked-into-plugin\n  //      dependencies of the package, not all transitive dependencies.\n  //  (b) It is ALWAYS put into the source tarball, even if the package came\n  //      from inside an app, whereas the package-source-tree .versions file\n  //      is only used for standalone packages\n  var packageMapFilename = files.pathJoin(sourcePackageDir, '.versions');\n  if (files.exists(packageMapFilename)) {\n    throw Error(\".versions file already exists? \" + packageMapFilename);\n  }\n  var pluginProviderPackageMap = isopack.pluginProviderPackageMap;\n  if (! pluginProviderPackageMap) {\n    throw Error(\"no pluginProviderPackageMap on isopack?\");\n  }\n  var packageMapFile = new projectContextModule.PackageMapFile({\n    filename: packageMapFilename\n  });\n  packageMapFile.write(pluginProviderPackageMap);\n\n  // We put this inside the temp dir because mkdtemp makes sure that the\n  // temp dir gets cleaned up on process exit, so we don't have to worry\n  // about cleaning up our tarball (or our copied source files)\n  // ourselves.\n  var sourceTarball = files.pathJoin(tempDir, packageTarName + '.tgz');\n  files.createTarball(dirToTar, sourceTarball);\n\n  var tarballHash = files.fileHash(sourceTarball);\n  var treeHash = files.treeHash(dirToTar);\n\n  return {\n    sourceTarball: sourceTarball,\n    tarballHash: tarballHash,\n    treeHash: treeHash\n  };\n};\n\n// Uploads a file at a filepath to the HTTP put URL.\n//\n// Returns true on success and false on failure.\nvar uploadFile = function (putUrl, filepath) {\n  buildmessage.assertInJob();\n  var size = files.stat(filepath).size;\n  var rs = files.createReadStream(filepath);\n  try {\n    // Use getUrl instead of request, to throw on 4xx/5xx.\n    httpHelpers.getUrl({\n      method: 'PUT',\n      url: putUrl,\n      headers: {\n        'content-length': size,\n        'content-type': 'application/octet-stream',\n        'x-amz-acl': 'public-read'\n      },\n      bodyStream: rs,\n      bodyStreamLength: size\n    });\n  } catch (err) {\n    // XXX: getUrl's error handling is terrible and we should fix it there.\n    buildmessage.error(typeof err === \"string\" ? err : err.error.toString());\n    return false;\n  } finally {\n    rs.close();\n  }\n  return true;\n};\n\nexports.uploadFile = uploadFile;\n\nexport function bundleBuild(isopack, isopackCache) {\n  buildmessage.assertInJob();\n\n  var tempDir = files.mkdtemp('bp-');\n  var packageTarName = isopack.tarballName();\n  var tarInputDir = files.pathJoin(tempDir, packageTarName);\n\n  // Note that we do need to do this even though we already have the isopack on\n  // disk in an IsopackCache, because we don't want to include\n  // isopack-buildinfo.json. (We don't include it because we're not passing\n  // includeIsopackBuildInfo to saveToPath here.)\n  isopack.saveToPath(tarInputDir, {\n    // When publishing packages that don't use new registerCompiler plugins,\n    // make sure that old Meteors can use it too\n    includePreCompilerPluginIsopackVersions: true,\n    isopackCache,\n  });\n\n  var buildTarball = files.pathJoin(tempDir, packageTarName + '.tgz');\n\n  files.createTarball(tarInputDir, buildTarball);\n\n  var tarballHash = files.fileHash(buildTarball);\n  var treeHash = files.treeHash(tarInputDir, {\n    // We don't include any package.json from an npm module in the tree hash,\n    // because npm isn't super consistent about what it puts in there (eg, does\n    // it include the \"readme\" field)? This ends up leading to spurious\n    // differences. The tree hash will still notice any actual CODE changes in\n    // the npm packages.\n    ignore: function (relativePath) {\n      var pieces = relativePath.split(files.pathSep);\n      return pieces.length && _.last(pieces) === 'package.json'\n        && _.contains(pieces, 'npm');\n    }\n  });\n\n  return {\n    buildTarball: buildTarball,\n    tarballHash: tarballHash,\n    treeHash: treeHash\n  };\n}\n\nfunction createBuiltPackage(isopack, isopackCache) {\n  buildmessage.assertInJob();\n  var name = isopack.name;\n\n  // Note: we really want to do this before createPackageBuild, because the URL\n  // we get from createPackageBuild will expire!\n  var bundleResult;\n  buildmessage.enterJob(\"bundling build for \" + name, function () {\n    bundleResult = bundleBuild(isopack, isopackCache);\n  });\n  if (buildmessage.jobHasMessages()) {\n    return;\n  }\n\n  return bundleResult;\n}\n\nvar publishBuiltPackage = function (conn, isopack, bundleResult) {\n  buildmessage.assertInJob();\n  var name = isopack.name;\n\n  var uploadInfo;\n  buildmessage.enterJob('creating package build for ' + name, function () {\n    uploadInfo = callPackageServerBM(conn, 'createPackageBuild', {\n      packageName: isopack.name,\n      version: isopack.version,\n      buildArchitectures: isopack.buildArchitectures()\n    });\n  });\n  if (buildmessage.jobHasMessages()) {\n    return;\n  }\n\n  buildmessage.enterJob(\"uploading build\", function () {\n    uploadFile(uploadInfo.uploadUrl,\n               bundleResult.buildTarball);\n  });\n  if (buildmessage.jobHasMessages()) {\n    return;\n  }\n\n  buildmessage.enterJob('publishing package build for ' + name, function () {\n    callPackageServerBM(conn, 'publishPackageBuild',\n                        uploadInfo.uploadToken,\n                        bundleResult.tarballHash,\n                        bundleResult.treeHash);\n  });\n  if (buildmessage.jobHasMessages()) {\n    return;\n  }\n};\n\nexport function createAndPublishBuiltPackage(conn, isopack, isopackCache) {\n  publishBuiltPackage(\n    conn,\n    isopack,\n    createBuiltPackage(isopack, isopackCache),\n  );\n}\n\n// Handle an error thrown on trying to connect to the package server.\nexports.handlePackageServerConnectionError = function (error) {\n  authClient.handleConnectionError(error, \"package server\");\n};\n\n\n// Update the package metdata in the server catalog. Chane the docs,\n// descriptions and the Git URL to new values.\n//\n// options:\n// - packageSource: the packageSource for this package.\n// - readmeInfo: null, or an object containing docs information for this package.\n// - connection: the open, logged-in connection over which we should talk to the\n//   package server. DO NOT CLOSE this connection here.\n//\n// Return true on success and an error code otherwise.\nexports.updatePackageMetadata = function (options) {\n  buildmessage.assertInJob();\n\n  var packageSource = options.packageSource;\n  var conn = options.connection;\n  var readmeInfo = options.readmeInfo;\n\n  var name = packageSource.name;\n  var version = packageSource.version;\n\n  if (! version) {\n    buildmessage.error(\n      \"Package cannot be updated because it doesn't have a version\");\n    return;\n  }\n\n  // For now, documentation is optional on the client, so we have to give people\n  // a way to remove it with 'documentation: null'.\n  if (! readmeInfo) {\n    readmeInfo = generateBlankReadme();\n  }\n\n  var dataToUpdate = {\n    git: packageSource.metadata.git || \"\",\n    description: packageSource.metadata.summary,\n    longDescription: readmeInfo.excerpt\n  };\n\n  // Check that the metadata fits under the established limits, and give helpful\n  // feedback.\n  if (! dataToUpdate[\"description\"]) {\n    buildmessage.error(\"Please provide a short description to use in 'meteor search'\");\n    return;\n  }\n\n  if (dataToUpdate[\"description\"] &&\n      dataToUpdate[\"description\"].length > 100) {\n    buildmessage.error(\"Summary must be under 100 chars.\");\n    return;\n  }\n\n  if (dataToUpdate[\"longDescription\"].length > 1500) {\n    buildmessage.error(\n      \"Longform package description is too long. Meteor uses the section of \" +\n      \"the Markdown documentation file between the first and second \" +\n      \"headings. That section must be less than 1500 characters long.\");\n    return;\n  }\n\n  // Update the general metadata.\n  var versionIdentifier = { packageName: name, version: version };\n  buildmessage.enterJob('updating metadata', function () {\n    callPackageServerBM(\n      conn, \"changeVersionMetadata\", versionIdentifier, dataToUpdate);\n  });\n  if (buildmessage.jobHasMessages()) {\n    return;\n  }\n\n  // Upload the new Readme.\n  buildmessage.enterJob('uploading documentation', function () {\n    var readmePath = saveReadmeToTmp(readmeInfo);\n    var uploadInfo =\n          callPackageServerBM(conn, \"createReadme\", versionIdentifier);\n    if (! uploadInfo) {\n      return;\n    }\n    if (! uploadFile(uploadInfo.url, readmePath)) {\n      return;\n    }\n    callPackageServerBM(\n      conn, \"publishReadme\", uploadInfo.uploadToken, { hash: readmeInfo.hash });\n  });\n  if (buildmessage.jobHasMessages()) {\n    return;\n  }\n\n\n};\n\n// Publish the package information into the server catalog. Create new records\n// for the package (if needed), the version and the build; upload source and\n// isopack.\n//\n// options:\n// - packageSource: the packageSource for this package.\n// - connection: the open, logged-in connection over which we should talk to the\n//   package server. DO NOT CLOSE this connection here.\n// - projectContext: the (probably temporary) ProjectContext to use. Must have\\\n//   already built local packages\n// - new: this package is new, we should call createPackage to create a new\n//   package record.\n// - existingVersion: we expect the version to exist already, and for us\n//   to merely be providing a new build of the same source\n// - doNotPublishBuild: do not publish the build of this package.\n//\n// Return true on success and an error code otherwise.\nexports.publishPackage = function (options) {\n  buildmessage.assertInJob();\n  var packageSource = options.packageSource;\n  var conn = options.connection;\n  var projectContext = options.projectContext;\n\n  var name = packageSource.name;\n  var version = packageSource.version;\n\n  if (options.new && options.existingVersion) {\n    throw Error(\"is it new or does it exist?!?\");\n  }\n\n  // Check that the package name is valid.\n  utils.validatePackageName(name, { useBuildmessage: true });\n  if (buildmessage.jobHasMessages()) {\n    return;\n  }\n\n  // Check that we have a version.\n  if (! version) {\n    buildmessage.error(\n      \"Package cannot be published because it doesn't have a version\");\n    return;\n  }\n\n  // Check that the version description is under the character limit. (We check\n  // all string limits on the server, but this is the one that is mostly likely\n  // to be wrong)\n  if (! packageSource.metadata.summary) {\n    buildmessage.error(\n      \"Please describe what your package does. Set a summary \" +\n        \"in Package.describe in package.js.\");\n    return;\n  }\n\n  if (packageSource.metadata.summary.length > 100) {\n    buildmessage.error(\"Summary must be under 100 chars.\");\n    return;\n  }\n\n  // Check that we are an authorized maintainer of this package.\n  if (!options['new']) {\n    var packRecord = catalog.official.getPackage(name);\n    if (! packRecord) {\n      buildmessage.error(\n        'There is no package named ' + name +\n          '. If you are creating a new package, use the --create flag.');\n      return;\n    }\n\n    if (!exports.amIAuthorized(name, conn, false)) {\n      buildmessage.error(\n        'You are not an authorized maintainer of ' + name + '.  Only ' +\n          'authorized maintainers may publish new versions.');\n    }\n  }\n\n  // Check that our documentation exists (or we know that it doesn't) and has\n  // been filled out.\n  var readmeInfo = buildmessage.enterJob(\n    \"processing documentation\",\n    function () {\n      return packageSource.processReadme();\n  });\n  if (buildmessage.jobHasMessages()) {\n    return;\n  }\n  if (readmeInfo && (readmeInfo.hash === files.blankHash)) {\n    buildmessage.error(\n      \"Your documentation file is blank, so users may have trouble figuring \" +\n      \"out how to use your package. Please fill it out, or \" +\n      \"set 'documentation: null' in your Package.describe\");\n    return;\n  }\n\n  if (readmeInfo && readmeInfo.excerpt.length > 1500) {\n    buildmessage.error(\n      \"Longform package description is too long. Meteor uses the section of \" +\n      \"the Markdown documentation file between the first and second \" +\n      \"headings. That section must be less than 1500 characters long.\");\n    return;\n  }\n\n  // We don't let the user upload a blank README for UX reasons, but we would\n  // prefer that the server move to a world with 'readme' files for everything\n  // in the future. This helps unite these interfaces, and makes our code easier\n  // to reason about in the future.\n  if (! readmeInfo) {\n    readmeInfo = generateBlankReadme();\n  }\n  var readmePath = saveReadmeToTmp(readmeInfo);\n\n  var packageDeps = packageSource.getDependencyMetadata();\n\n  // Check that the package does not have any unconstrained references.\n  _.each(packageDeps, function(refs, label) {\n    if (refs.constraint == null) {\n      if (packageSource.isCore && files.inCheckout() &&\n          projectContext.localCatalog.getPackage(label)) {\n        // Core package is using or implying another core package,\n        // without a version number.  We fill in the version number.\n        // (Well, we're assuming that the other package is core and\n        // not some other sort of local package.)\n        var versionString =\n              projectContext.localCatalog.getLatestVersion(label).version;\n        // modify the constraint on this dep that will be sent to troposphere\n        refs.constraint = versionString;\n      } else if (label === \"meteor\") {\n        // HACK: We are willing to publish a package with a \"null\"\n        // constraint on the \"meteor\" package to troposphere.  This\n        // happens for non-core packages when not running from a\n        // checkout, because all packages implicitly depend on the\n        // \"meteor\" package, but do not necessarily specify an\n        // explicit version for it, and we don't have a great way to\n        // choose one here.\n        // XXX come back to this, especially if we are incrementing the\n        // major version of \"meteor\".  hopefully we will have more data\n        // about the package system by then.\n      } else {\n        buildmessage.error(\n          \"You must specify a version constraint for package \" + label);\n      }\n    }\n  });\n  if (buildmessage.jobHasMessages()) {\n    return;\n  }\n\n  var isopack = projectContext.isopackCache.getIsopack(name);\n  if (! isopack) {\n    throw Error(\"no isopack \" + name);\n  }\n\n  // If we aren't able to include legacy builds in this version, make sure that\n  // it has a fake dependency on isobuild:isopack-2 so that old versions of\n  // Isobuild won't accidentally use it.\n  if (!isopack.canWriteLegacyBuilds()\n      && !_.has(packageDeps, 'isobuild:isopack-2')) {\n    packageDeps['isobuild:isopack-2'] = {\n      constraint: '1.0.0',\n      // Arbitrary arch here; nothing other than meteor show really pays\n      // attention to reference arch anymore, because we no longer pay attention\n      // to the arch with the constraint in Version Solver.\n      references: [{arch: 'os'}],\n    };\n  }\n\n  var sourceFiles = isopack.getSourceFilesUnderSourceRoot(\n    packageSource.sourceRoot);\n  if (! sourceFiles) {\n    throw Error(\"isopack doesn't know what its source files are?\");\n  }\n\n  // We need to have built the test package to get all of its sources, even\n  // though we're not publishing a BUILD for the test package.\n  if (packageSource.testName) {\n    var testIsopack = projectContext.isopackCache.getIsopack(\n      packageSource.testName);\n    if (! testIsopack) {\n      throw Error(\"no testIsopack \" + packageSource.testName);\n    }\n    var testSourceFiles = testIsopack.getSourceFilesUnderSourceRoot(\n      packageSource.sourceRoot);\n    if (! testSourceFiles) {\n      throw Error(\"test isopack doesn't know what its source files are?\");\n    }\n    sourceFiles = _.union(sourceFiles, testSourceFiles);\n  }\n\n  var sourceBundleResult;\n  buildmessage.enterJob(\"bundling source for \" + name, function () {\n    sourceBundleResult = bundleSource(\n      isopack, sourceFiles, packageSource.sourceRoot);\n  });\n  if (buildmessage.jobHasMessages()) {\n    return;\n  }\n\n  // Create the package. Check that the metadata exists.\n  if (options.new) {\n    buildmessage.enterJob(\"creating package \" + name, function () {\n      callPackageServerBM(conn, 'createPackage', {\n        name: packageSource.name\n      });\n    });\n    if (buildmessage.jobHasMessages()) {\n      return;\n    }\n  }\n\n  if (options.existingVersion) {\n    var existingRecord = catalog.official.getVersion(name, version);\n    if (! existingRecord) {\n      buildmessage.error(\"Version does not exist.\");\n      return;\n    }\n    if (existingRecord.source.treeHash !== sourceBundleResult.treeHash) {\n      buildmessage.error(\"Package source differs from the existing version.\");\n      return;\n    }\n\n    if (! options.doNotPublishBuild) {\n      createAndPublishBuiltPackage(\n        conn, isopack, projectContext.isopackCache);\n\n      if (buildmessage.jobHasMessages()) {\n        return;\n      }\n    }\n\n    // XXX check that we're actually providing something new?\n  } else {\n    var uploadInfo;\n    buildmessage.enterJob(\"pre-publishing package \" + name, function () {\n      var uploadRec = {\n        packageName: packageSource.name,\n        version: version,\n        description: packageSource.metadata.summary,\n        longDescription: readmeInfo.excerpt,\n        git: packageSource.metadata.git,\n        compilerVersion: compiler.BUILT_BY,\n        containsPlugins: packageSource.containsPlugins(),\n        debugOnly: packageSource.debugOnly,\n        prodOnly: packageSource.prodOnly,\n        testOnly: packageSource.testOnly,\n        exports: packageSource.getExports(),\n        releaseName: release.current.name,\n        dependencies: packageDeps\n      };\n      uploadInfo = callPackageServerBM(conn, 'createPackageVersion', uploadRec);\n    });\n    if (buildmessage.jobHasMessages()) {\n      return;\n    }\n\n    // XXX If package version already exists, print a nice error message\n    // telling them to try 'meteor publish-for-arch' if they want to\n    // publish a new build.\n\n    // Documentation is smaller than the source. Upload it first, to minimize\n    // the chances of PUT URLs expiring. (XXX: in the far future, parallelize this)\n    buildmessage.enterJob(\"uploading documentation\", function () {\n      uploadFile(uploadInfo.readmeUrl, readmePath);\n    });\n    if (buildmessage.jobHasMessages()) {\n      return;\n    }\n\n    buildmessage.enterJob(\"uploading source\", function () {\n      uploadFile(uploadInfo.uploadUrl, sourceBundleResult.sourceTarball);\n    });\n    if (buildmessage.jobHasMessages()) {\n      return;\n    }\n\n    if (! options.doNotPublishBuild) {\n      var bundleResult = createBuiltPackage(\n        isopack,\n        projectContext.isopackCache,\n      );\n\n      if (buildmessage.jobHasMessages()) {\n        return;\n      }\n    }\n\n    var hashes = {\n      tarballHash: sourceBundleResult.tarballHash,\n      treeHash: sourceBundleResult.treeHash,\n      readmeHash: readmeInfo.hash\n    };\n    buildmessage.enterJob(\"publishing package version\", function () {\n      callPackageServerBM(\n        conn, 'publishPackageVersion', uploadInfo.uploadToken, hashes);\n    });\n    if (buildmessage.jobHasMessages()) {\n      return;\n    }\n\n    if (! options.doNotPublishBuild) {\n      publishBuiltPackage(conn, isopack, bundleResult);\n      if (buildmessage.jobHasMessages()) {\n        return;\n      }\n    }\n  }\n\n  return;\n};\n\n  // Call the server to ask if we are authorized to update this release or\n// package. This is a way to save time before sending data to the server. It\n// will mostly ignore most errors (just in case we have a flaky network connection or\n// something) and let the method deal with those.\n//\n// If this returns FALSE, then we are NOT authorized.\n// Otherwise, return true.\nexports.amIAuthorized = function (name, conn, isRelease) {\n  var methodName = \"amIAuthorized\" +\n    (isRelease ? \"Release\" : \"Package\");\n\n  try {\n    exports.callPackageServer(conn, methodName, name);\n  } catch (err) {\n    if (err.error === 401) {\n      return false;\n    }\n\n    // We don't know what this error is. Probably we can't contact the server,\n    // or the like. It would be a pity to fail all operations with the server\n    // just because a preliminary check fails, so return true for now.\n    return true;\n  }\n  return true;\n};\n"]}