{"version":3,"sources":["/tools/fs/watch.js"],"names":["module","export","WatchSet","readFile","sha1","readDirectory","Watcher","isUpToDate","readAndWatchDirectory","readAndWatchFileWithHash","readAndWatchFile","files","watch","require","default","v","_","safeWatcher","createHash","coalesce","Profile","optimisticStatOrNull","optimisticReaddir","optimisticHashOrNull","constructor","self","alwaysFire","directories","addFile","filePath","hash","has","addDirectory","absPath","include","exclude","names","contents","unsortedContents","isEmpty","clone","sort","push","merge","other","each","name","dir","ret","toJSON","reToJSON","r","options","ignoreCase","multiline","global","$regex","source","$options","map","d","fromJSON","json","set","reFromJSON","j","RegExp","e","code","args","forEach","arg","update","digest","readdir","contentsWithSlashes","entry","stat","statOrNull","pathJoin","isDirectory","filtered","filter","indexOf","some","re","test","watchSet","Error","onChange","stopped","justCheckOnce","_justCheckOnce","watches","_fire","_startFileWatches","_checkDirectories","_fireIfFileChanged","oldHash","undefined","newHash","_fireIfDirectoryChanged","info","newContents","isEqual","_watchFileOrDirectory","watcher","lastStat","_mustNotExist","onWatchEvent","_makeWatchEventCallback","_mustBeAFile","parentDir","pathDirname","_updateStatForWatch","isFile","dirFiles","err","file","fullPath","wsFiles","isString","mustNotExist","mustBeAFile","stop","close","time","upToDate","extend","result"],"mappings":"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","file":"tools/fs/watch.js.map","sourcesContent":["import files from './files.js';\nimport _ from \"underscore\";\nimport * as safeWatcher from './safe-watcher.js';\nimport {createHash} from \"crypto\";\nimport {coalesce} from '../utils/func-utils.js';\nimport {Profile} from '../tool-env/profile.js';\n\nimport {\n  optimisticStatOrNull,\n  optimisticReaddir,\n  optimisticHashOrNull,\n} from \"./optimistic.js\";\n\n// Watch for changes to a set of files, and the first time that any of\n// the files change, call a user-provided callback. (If you want a\n// second callback, you'll need to create a second Watcher.)\n//\n// You describe the structure you want to watch in a WatchSet; you then create a\n// Watcher to watch it. Watcher does not mutate WatchSet, so you can create\n// several Watchers from the same WatchSet. WatchSet can be easily converted to\n// and from JSON for serialization.\n//\n// You can set up two kinds of watches, file and directory watches.\n//\n// In a file watch, you provide an absolute path to a file and a SHA1 (encoded\n// as hex) of the contents of that file. If the file ever changes so that its\n// contents no longer match that SHA1, the callback triggers. You can also\n// provide `null` for the SHA1, which means the file should not exist.\n//\n// In a directory watch, you provide an absolute path to a directory,\n// two lists of regular expressions specifying the entries to\n// include and exclude, a list of specific names to include (which ignores\n// the exclude regexp list) and an array of which entries to expect.\n//\n// For directory watches, the regular expressions work as follows. You provide\n// two arrays of regular expressions, an include list and an exclude list. An\n// entry in the directory matches if it matches at least one regular expression\n// in the include list, and doesn't match any regular expressions in the exclude\n// list. The string that is matched against the regular expression ends with a\n// '/' if the entry is directory. There is NO IMPLICIT RECURSION here: a\n// directory watch ONLY watches the immediate children of the directory! If you\n// want a recursive watch, you need to do the recursive walk while building the\n// WatchSet and add a bunch of separate directory watches.  In addition, you\n// can provide a list of specific names to expect; these are not filtered\n// by the exclude list.  (For example, you might want to see all \"*.js\" files\n// but ignore files starting with dots (which are often temporary files), but\n// explicitly ask for \".jshintrc\".)\n//\n// There can be multiple directory watches on the same directory. There is no\n// relationship between the files found in directory watches and the files\n// watched by file watches; they are parallel mechanisms.\n//\n// Regular expressions are checked only against individual path components (the\n// actual name of the file or the subdirectory) plus the trailing '/' for\n// directories, not against the entire path.\n//\n// You can call stop() to stop watching and tear down the\n// watcher. Calling stop() guarantees that you will not receive a\n// callback (if you have not already). Calling stop() is unnecessary\n// if you've received a callback.\n//\n// To do a \"one-shot\" (to see if any files have been modified, compared to the\n// dependencies, at a particular point in time), use the isUpToDate function.\n//\n// XXX Symlinks are currently treated transparently: we treat them as the thing\n// they point to (ie, as a directory if they point to a directory, as\n// nonexistent if they point to something nonexist, etc). Not sure if this is\n// correct.\n\nexport class WatchSet {\n  constructor() {\n    var self = this;\n\n    // Set this to true if any Watcher built on this WatchSet must immediately\n    // fire (eg, if this WatchSet was given two different sha1 for the same file).\n    self.alwaysFire = false;\n\n    // Map from the absolute path to a file, to a sha1 hash, or null if the file\n    // should not exist. A Watcher created from this set fires when the file\n    // changes from that sha, or is deleted (if non-null) or created (if null).\n    //\n    // Note that Isopack.getSourceFilesUnderSourceRoot() depends on this field\n    // existing (it's not just an internal implementation detail of watch.js).\n    self.files = {};\n\n    // Array of object with keys:\n    // - 'absPath': absolute path to a directory\n    // - 'include': array of RegExps\n    // - 'exclude': array of RegExps\n    // - 'names': array of strings\n    // - 'contents': array of strings, or null if the directory should not exist\n    //\n    // This represents the assertion that 'absPath' is a directory and that\n    // 'contents' is its immediate contents, as filtered by the regular\n    // expressions.  Entries in 'contents' are file and subdirectory names;\n    // directory names end with '/'. 'contents' is sorted. An entry is in\n    // 'contents' if its value (including the slash, for directories) matches at\n    // least one regular expression in 'include' and no regular expressions in\n    // 'exclude'... or if it is in 'names'.\n    //\n    // There is no recursion here: files contained in subdirectories never appear.\n    //\n    // A directory may have multiple entries (presumably with different\n    // include/exclude filters).\n    self.directories = [];\n  }\n\n  addFile(filePath, hash) {\n    var self = this;\n    // No need to update if this is in always-fire mode already.\n    if (self.alwaysFire) {\n      return;\n    }\n    if (_.has(self.files, filePath)) {\n      // Redundant?\n      if (self.files[filePath] === hash) {\n        return;\n      }\n      // Nope, inconsistent.\n      self.alwaysFire = true;\n      return;\n    }\n    self.files[filePath] = hash;\n  }\n\n  addDirectory({absPath, include, exclude, names, contents: unsortedContents}) {\n    var self = this;\n    if (self.alwaysFire) {\n      return;\n    }\n    if (_.isEmpty(include) && _.isEmpty(names)) {\n      return;\n    }\n    const contents = _.clone(unsortedContents);\n    if (contents) {\n      contents.sort();\n    }\n\n    self.directories.push({absPath, include, exclude, names, contents});\n  }\n\n  // Merges another WatchSet into this one. This one will now fire if either\n  // WatchSet would have fired.\n  merge(other) {\n    var self = this;\n    if (self.alwaysFire) {\n      return;\n    }\n    if (other.alwaysFire) {\n      self.alwaysFire = true;\n      return;\n    }\n   _.each(other.files, function (hash, name) {\n     self.addFile(name, hash);\n   });\n    _.each(other.directories, function (dir) {\n      // XXX this doesn't deep-clone the directory, but I think these objects\n      // are never mutated #WatchSetShallowClone\n      self.directories.push(dir);\n    });\n  }\n\n  clone() {\n    var self = this;\n    var ret = new WatchSet();\n\n    // XXX doesn't bother to deep-clone the directory info\n    // #WatchSetShallowClone\n    ret.alwaysFire = self.alwaysFire;\n    ret.files = _.clone(self.files);\n    ret.directories = _.clone(self.directories);\n    return ret;\n  }\n\n  toJSON() {\n    var self = this;\n    if (self.alwaysFire) {\n      return {alwaysFire: true};\n    }\n    var ret = {files: self.files};\n\n    var reToJSON = function (r) {\n      var options = '';\n      if (r.ignoreCase) {\n        options += 'i';\n      }\n      if (r.multiline) {\n        options += 'm';\n      }\n      if (r.global) {\n        options += 'g';\n      }\n      if (options) {\n        return {$regex: r.source, $options: options};\n      }\n      return r.source;\n    };\n\n    ret.directories = _.map(self.directories, function (d) {\n      return {\n        absPath: d.absPath,\n        include: _.map(d.include, reToJSON),\n        exclude: _.map(d.exclude, reToJSON),\n        names: d.names,\n        contents: d.contents\n      };\n    });\n\n    return ret;\n  }\n\n  static fromJSON(json) {\n    var set = new WatchSet();\n\n    if (! json) {\n      return set;\n    }\n\n    if (json.alwaysFire) {\n      set.alwaysFire = true;\n      return set;\n    }\n\n    set.files = _.clone(json.files);\n\n    var reFromJSON = function (j) {\n      if (_.has(j, '$regex')) {\n        return new RegExp(j.$regex, j.$options);\n      }\n      return new RegExp(j);\n    };\n\n    set.directories = _.map(json.directories, function (d) {\n      return {\n        absPath: d.absPath,\n        include: _.map(d.include, reFromJSON),\n        exclude: _.map(d.exclude, reFromJSON),\n        names: d.names,\n        contents: d.contents\n      };\n    });\n\n    return set;\n  }\n}\n\nexport function readFile(absPath) {\n  try {\n    return files.readFile(absPath);\n  } catch (e) {\n    // Rethrow most errors.\n    if (! e || (e.code !== 'ENOENT' && e.code !== 'EISDIR')) {\n      throw e;\n    }\n    // File does not exist (or is a directory).\n    return null;\n  }\n};\n\nexport function sha1(...args) {\n  return Profile(\"sha1\", function () {\n    var hash = createHash('sha1');\n    args.forEach(arg => hash.update(arg));\n    return hash.digest('hex');\n  })();\n}\n\nexport function readDirectory({absPath, include, exclude, names}) {\n  // Read the directory.\n  try {\n    var contents = files.readdir(absPath);\n  } catch (e) {\n    // If the path is not a directory, return null; let other errors through.\n    if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) {\n      return null;\n    }\n    throw e;\n  }\n\n  // Add slashes to the end of directories.\n  var contentsWithSlashes = [];\n  _.each(contents, function (entry) {\n    // We do stat instead of lstat here, so that we treat symlinks to\n    // directories just like directories themselves.\n    const stat = files.statOrNull(files.pathJoin(absPath, entry));\n    if (! stat) {\n      // Disappeared after the readdir (or a dangling symlink)?\n      // Eh, pretend it was never there in the first place.\n      return;\n    }\n\n    if (stat.isDirectory()) {\n      entry += '/';\n    }\n\n    contentsWithSlashes.push(entry);\n  });\n\n  // Filter based on regexps.\n  var filtered = contentsWithSlashes.filter((entry) => {\n    // Is it one of the names we explicitly requested?\n    if (names && names.indexOf(entry) !== -1) {\n      return true;\n    }\n    // Is it ruled out by an exclude rule?\n    if (exclude && exclude.some(re => re.test(entry))) {\n      return false;\n    }\n    // Is it ruled in by an include rule?\n    if (include && include.some(re => re.test(entry))) {\n      return true;\n    }\n    return false;\n  });\n\n  // Sort it!\n  filtered.sort();\n  return filtered;\n}\n\n// All fields are private.\nexport class Watcher {\n  constructor(options) {\n    var self = this;\n\n    // The set to watch.\n    self.watchSet = options.watchSet;\n    if (! self.watchSet) {\n      throw new Error(\"watchSet option is required\");\n    }\n\n    // Function to call when a change is detected according to one of\n    // the above.\n    self.onChange = options.onChange;\n    if (! self.onChange) {\n      throw new Error(\"onChange option is required\");\n    }\n\n    self.stopped = false;\n    self.justCheckOnce = !! options._justCheckOnce;\n\n    self.watches = {\n      // <absolute path of watched file or directory>: {\n      //   // Null until safeWatcher.watch succeeds in watching the file.\n      //   watcher: <object returned by safeWatcher.watch> | null,\n      //   // Undefined until we stat the file for the first time, then null\n      //   // if the file is observed to be missing.\n      //   lastStat: <object returned by files.stat> | null | undefined\n      // }\n    };\n\n    // Were we given an inconsistent WatchSet? Fire now and be done with it.\n    if (self.watchSet.alwaysFire) {\n      self._fire();\n      return;\n    }\n\n    self._startFileWatches();\n    self._checkDirectories();\n  }\n\n  _fireIfFileChanged(absPath) {\n    var self = this;\n\n    if (self.stopped) {\n      return true;\n    }\n\n    var oldHash = self.watchSet.files[absPath];\n\n    if (oldHash === undefined) {\n      throw new Error(\"Checking unknown file \" + absPath);\n    }\n\n    var newHash = optimisticHashOrNull(absPath);\n\n    if (newHash === null) {\n      // File does not exist (or is a directory).\n      // Is this what we expected?\n      if (oldHash === null) {\n        return false;\n      }\n      // Nope, not what we expected.\n      self._fire();\n      return true;\n    }\n\n    // File exists! Is that what we expected?\n    if (oldHash === null) {\n      self._fire();\n      return true;\n    }\n\n    // Unchanged?\n    if (newHash === oldHash) {\n      return false;\n    }\n\n    self._fire();\n    return true;\n  }\n\n  _fireIfDirectoryChanged(info) {\n    var self = this;\n\n    if (self.stopped) {\n      return true;\n    }\n\n    var newContents = readDirectory({\n      absPath: info.absPath,\n      include: info.include,\n      exclude: info.exclude,\n      names: info.names\n    });\n\n    // If the directory has changed (including being deleted or created).\n    if (! _.isEqual(info.contents, newContents)) {\n      self._fire();\n      return true;\n    }\n\n    return false;\n  }\n\n  _startFileWatches() {\n    var self = this;\n\n    // Set up a watch for each file\n    _.each(self.watchSet.files, function (hash, absPath) {\n      if (self.stopped) {\n        return;\n      }\n\n      if (! self.justCheckOnce) {\n        self._watchFileOrDirectory(absPath);\n      }\n\n      // Check for the case where by the time we created the watch,\n      // the file had already changed from the sha we were provided.\n      self._fireIfFileChanged(absPath);\n    });\n  }\n\n  _watchFileOrDirectory(absPath) {\n    var self = this;\n\n    if (! _.has(self.watches, absPath)) {\n      self.watches[absPath] = {\n        watcher: null,\n        // Initially undefined (instead of null) to indicate we have never\n        // called files.stat on this file before.\n        lastStat: undefined\n      };\n    }\n\n    var entry = self.watches[absPath];\n    if (entry.watcher) {\n      // Already watching this path.\n      return;\n    }\n\n    if (files.statOrNull(absPath)) {\n      if (self._mustNotExist(absPath)) {\n        self._fire();\n        return;\n      }\n\n      var onWatchEvent = self._makeWatchEventCallback(absPath);\n      entry.watcher = safeWatcher.watch(absPath, onWatchEvent);\n\n      // If we successfully created the watcher, invoke the callback\n      // immediately, so that we examine this file at least once.\n      onWatchEvent();\n\n    } else {\n      if (self._mustBeAFile(absPath)) {\n        self._fire();\n        return;\n      }\n\n      var parentDir = files.pathDirname(absPath);\n      if (parentDir === absPath) {\n        throw new Error(\"Unable to watch parent directory of \" + absPath);\n      }\n\n      self._watchFileOrDirectory(parentDir);\n    }\n  }\n\n  _makeWatchEventCallback(absPath) {\n    var self = this;\n\n    // Sometimes we receive a rapid succession of change events, perhaps\n    // because several files were modified at once (e.g. by git reset\n    // --hard), or a file was deleted and then recreated by an editor like\n    // Vim. Because detecting changes can be costly, and because we care\n    // most about the settled state of the file system, we use the\n    // funcUtils.coalesce helper to delay calls to the callback by 100ms,\n    // canceling any additional calls if they happen within that window of\n    // time, so that a rapid succession of calls will tend to trigger only\n    // one inspection of the file system.\n    return coalesce(100, function onWatchEvent() {\n      if (self.stopped) {\n        return;\n      }\n\n      // This helper method will call self._fire() if the old and new stat\n      // objects have different types (missing, file, or directory), so we\n      // can assume they have the same type for the rest of this method.\n      var stat = self._updateStatForWatch(absPath);\n      if (self.stopped) {\n        return;\n      }\n\n      if (stat === null || stat.isFile()) {\n        if (_.has(self.watchSet.files, absPath)) {\n          self._fireIfFileChanged(absPath);\n          // XXX #3335 We probably should check again in a second, due to low\n          // filesystem modtime resolution.\n        }\n\n      } else if (stat.isDirectory()) {\n        try {\n          var dirFiles = files.readdir(absPath);\n        } catch (err) {\n          if (err.code === \"ENOENT\" ||\n              err.code === \"ENOTDIR\") {\n            // The directory was removed or changed type since we called\n            // self._updateStatForWatch, so we fire unconditionally.\n            self._fire();\n            return;\n          }\n          throw err;\n        }\n\n        _.each(dirFiles, function(file) {\n          var fullPath = files.pathJoin(absPath, file);\n\n          // Recursively watch new files, if we ever previously tried to\n          // watch them. Recall that when we attempt to watch a\n          // non-existent file, we actually watch the closest enclosing\n          // directory that exists, so once the file (and/or any\n          // intermediate directories) are created, we begin watching\n          // those directories in response to change events fired for\n          // directories we're already watching.\n          if (_.has(self.watches, fullPath)) {\n            self._watchFileOrDirectory(fullPath);\n          }\n        });\n\n        // If self.watchSet.directories contains any entries for the\n        // directory we are examining, call self._fireIfDirectoryChanged.\n        _.some(self.watchSet.directories, function(info) {\n          return self.stopped ||\n            (absPath === info.absPath &&\n             self._fireIfDirectoryChanged(info, true));\n          // XXX #3335 We probably should check again in a second, due to low\n          // filesystem modtime resolution.\n        });\n      }\n    });\n  }\n\n  _mustNotExist(absPath) {\n    var wsFiles = this.watchSet.files;\n    if (_.has(wsFiles, absPath)) {\n      return wsFiles[absPath] === null;\n    }\n    return false;\n  }\n\n  _mustBeAFile(absPath) {\n    var wsFiles = this.watchSet.files;\n    if (_.has(wsFiles, absPath)) {\n      return _.isString(wsFiles[absPath]);\n    }\n    return false;\n  }\n\n  _updateStatForWatch(absPath) {\n    var self = this;\n    var entry = self.watches[absPath];\n    var lastStat = entry.lastStat;\n    var stat = files.statOrNull(absPath);\n    var mustNotExist = self._mustNotExist(absPath);\n    var mustBeAFile = self._mustBeAFile(absPath);\n\n    if (stat && lastStat === undefined) {\n      // We have not checked for this file before, so our expectations are\n      // somewhat relaxed (namely, we don't care about lastStat), but\n      // self._fire() might still need to be called if self.watchSet.files\n      // has conflicting expectations.\n      if (stat.isFile()) {\n        if (mustNotExist) {\n          self._fire();\n        }\n      } else if (stat.isDirectory()) {\n        if (mustNotExist || mustBeAFile) {\n          self._fire();\n        }\n      } else {\n        // Neither a file nor a directory, so treat as non-existent.\n        stat = null;\n        if (mustBeAFile) {\n          self._fire();\n        }\n      }\n\n      // We have not checked for this file before, so just record the new\n      // stat object.\n      entry.lastStat = stat;\n\n    } else if (stat && stat.isFile()) {\n      entry.lastStat = stat;\n      if (! lastStat || ! lastStat.isFile()) {\n        self._fire();\n      }\n\n    } else if (stat && stat.isDirectory()) {\n      entry.lastStat = stat;\n      if (! lastStat || ! lastStat.isDirectory()) {\n        self._fire();\n      }\n\n    } else {\n      entry.lastStat = stat = null;\n      if (lastStat) {\n        self._fire();\n      }\n    }\n\n    return stat;\n  }\n\n  _checkDirectories() {\n    var self = this;\n\n    if (self.stopped) {\n      return;\n    }\n\n    _.each(self.watchSet.directories, function (info) {\n      if (self.stopped) {\n        return;\n      }\n\n      if (! self.justCheckOnce) {\n        self._watchFileOrDirectory(info.absPath);\n      }\n\n      // Check for the case where by the time we created the watch, the\n      // directory has already changed.\n      self._fireIfDirectoryChanged(info);\n    });\n  }\n\n  _fire() {\n    var self = this;\n\n    if (self.stopped) {\n      return;\n    }\n\n    self.stop();\n    self.onChange();\n  }\n\n  stop() {\n    var self = this;\n    self.stopped = true;\n\n    // Clean up file watches\n    _.each(self.watches, function (entry) {\n      if (entry.watcher) {\n        entry.watcher.close();\n        entry.watcher = null;\n      }\n    });\n    self.watches = {};\n  }\n}\n\n// Given a WatchSet, returns true if it currently describes the state of the\n// disk.\nexport function isUpToDate(watchSet) {\n  return Profile.time('watch.isUpToDate', () => {\n    var upToDate = true;\n    var watcher = new Watcher({\n      watchSet: watchSet,\n      onChange: function () {\n        upToDate = false;\n      },\n      // internal flag which prevents us from starting watches and timers that\n      // we're about to cancel anyway\n      _justCheckOnce: true\n    });\n    watcher.stop();\n    return upToDate;\n  });\n}\n\n// Options should have absPath/include/exclude/names.\nexport function readAndWatchDirectory(watchSet, options) {\n  var contents = readDirectory(options);\n  watchSet.addDirectory(_.extend({contents: contents}, options));\n  return contents;\n}\n\n// Calculating the sha hash can be expensive for large files.  By\n// returning the calculated hash along with the file contents, the\n// hash doesn't need to be calculated again for static files.\n//\n// We only calculate the hash if needed here, so callers must not\n// *rely* on the hash being returned; merely that if the hash is\n// present, it is the correct hash of the contents.\nexport function readAndWatchFileWithHash(watchSet, absPath) {\n  const result = {\n    contents: null,\n    hash: null,\n  };\n\n  try {\n    result.contents = files.readFile(absPath);\n  } catch (e) {\n    if (e && e.code === \"EISDIR\") {\n      // Avoid adding directories to the watchSet as files.\n      return result;\n    }\n\n    if (e && e.code === \"ENOENT\") {\n      // Continue, leaving result.{contents,hash} both null.\n    } else {\n      // Throw all other errors.\n      throw e;\n    }\n  }\n\n  if (result.contents !== null) {\n    result.hash = sha1(result.contents);\n  }\n\n  // Allow null watchSet, if we want to use readFile-style error handling in a\n  // context where we might not always have a WatchSet (eg, reading\n  // settings.json where we watch for \"meteor run\" but not for \"meteor deploy\").\n  if (watchSet) {\n    watchSet.addFile(absPath, result.hash);\n  }\n\n  return result;\n}\n\nexport function readAndWatchFile(watchSet, absPath) {\n  return readAndWatchFileWithHash(watchSet, absPath).contents;\n}\n"]}