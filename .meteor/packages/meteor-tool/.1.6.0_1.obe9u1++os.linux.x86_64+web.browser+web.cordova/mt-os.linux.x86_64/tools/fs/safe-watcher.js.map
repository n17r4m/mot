{"version":3,"sources":["/tools/fs/safe-watcher.js"],"names":["module","export","closeAllWatchers","watch","watchLibrary","require","v","Profile","statOrNull","pathDirname","pathResolve","convertToOSPath","convertToStandardPath","watchFile","unwatchFile","WATCHER_ENABLED","JSON","parse","process","env","METEOR_WATCH_FORCE_POLLING","PRIORITIZE_CHANGED","METEOR_WATCH_PRIORITIZE_CHANGED","DEFAULT_POLLING_INTERVAL","METEOR_WATCH_POLLING_INTERVAL_MS","NO_WATCHER_POLLING_INTERVAL","WATCHER_CLEANUP_DELAY_MS","entries","Object","create","entriesByIno","Map","changedPaths","Set","hasPriority","absPath","has","acquireWatcher","callback","entry","startNewWatcher","rewatch","callbacks","add","stat","ino","get","safeUnwatch","watcher","close","delete","lastWatcherEventTime","Date","watcherCleanupTimer","getPollingInterval","fire","event","forEach","cb","call","watchWrapper","watchLibraryWatch","statWatch","watchFileWrapper","args","newStat","oldStat","mtime","release","size","clearTimeout","setTimeout","set","keys","statWatchers","interval","oldWatcher","countBefore","listenerCount","removeListener","persistent","newWatcher","on","stop","start","e","maybeSuggestRaisingWatchLimit","suggestedRaisingWatchLimit","error","constants","archinfo","errno","ENOSPC","matches","host","Console","isHeadless","arrowWarn","url"],"mappings":"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","file":"tools/fs/safe-watcher.js.map","sourcesContent":["import * as watchLibrary from \"pathwatcher\";\nimport { Profile } from \"../tool-env/profile.js\";\nimport {\n  statOrNull,\n  pathDirname,\n  pathResolve,\n  convertToOSPath,\n  convertToStandardPath,\n  watchFile,\n  unwatchFile,\n} from \"./files.js\";\n\n// Set METEOR_WATCH_FORCE_POLLING environment variable to a truthy value to\n// force the use of files.watchFile instead of watchLibrary.watch.\nvar WATCHER_ENABLED = ! JSON.parse(\n  process.env.METEOR_WATCH_FORCE_POLLING || \"false\"\n);\n\n// Default to prioritizing changed files, but disable that behavior (and\n// thus prioritize all files equally) if METEOR_WATCH_PRIORITIZE_CHANGED\n// is explicitly set to a string that parses to a falsy value.\nvar PRIORITIZE_CHANGED = true;\nif (process.env.METEOR_WATCH_PRIORITIZE_CHANGED &&\n    ! JSON.parse(process.env.METEOR_WATCH_PRIORITIZE_CHANGED)) {\n  PRIORITIZE_CHANGED = false;\n}\n\nvar DEFAULT_POLLING_INTERVAL =\n  ~~process.env.METEOR_WATCH_POLLING_INTERVAL_MS || 5000;\n\nvar NO_WATCHER_POLLING_INTERVAL =\n  ~~process.env.METEOR_WATCH_POLLING_INTERVAL_MS || 500;\n\n// This may seems like a long time to wait before actually closing the\n// file watchers, but it's to our advantage if they survive restarts.\nconst WATCHER_CLEANUP_DELAY_MS = 30000;\n\nconst entries = Object.create(null);\n\n// Pathwatcher complains (using console.error, ugh) if you try to watch\n// two files with the same stat.ino number but different paths, so we have\n// to deduplicate files by ino.\nconst entriesByIno = new Map;\n\n// Set of paths for which a change event has been fired, watched with\n// watchLibrary.watch if available. This could be an LRU cache, but in\n// practice it should never grow large enough for that to matter.\nconst changedPaths = new Set;\n\nfunction hasPriority(absPath) {\n  // If we're not prioritizing changed files, then all files have\n  // priority, which means they should be watched with native file\n  // watchers if the platform supports them. If we are prioritizing\n  // changed files, then only changed files get priority.\n  return PRIORITIZE_CHANGED\n    ? changedPaths.has(absPath)\n    : true;\n}\n\nfunction acquireWatcher(absPath, callback) {\n  const entry = entries[absPath] || (\n    entries[absPath] = startNewWatcher(absPath));\n\n  // Watches successfully established in the past may have become invalid\n  // because the watched file was deleted or renamed, so we need to make\n  // sure we're still watching every time we call safeWatcher.watch.\n  entry.rewatch();\n\n  // The size of the entry.callbacks Set also serves as a reference count\n  // for this watcher.\n  entry.callbacks.add(callback);\n\n  return entry;\n}\n\nfunction startNewWatcher(absPath) {\n  const stat = statOrNull(absPath);\n  const ino = stat && stat.ino;\n  if (ino > 0 && entriesByIno.has(ino)) {\n    const entry = entriesByIno.get(ino);\n    if (entries[absPath] === entry) {\n      return entry;\n    }\n  }\n\n  function safeUnwatch() {\n    if (watcher) {\n      watcher.close();\n      watcher = null;\n      if (ino > 0) {\n        entriesByIno.delete(ino);\n      }\n    }\n  }\n\n  let lastWatcherEventTime = +new Date;\n  const callbacks = new Set;\n  let watcherCleanupTimer = null;\n  let watcher;\n\n  // Determines the polling interval to be used for the fs.watchFile-based\n  // safety net that works on all platforms and file systems.\n  function getPollingInterval() {\n    if (hasPriority(absPath)) {\n      // Regardless of whether we have a native file watcher and it works\n      // correctly on this file system, poll prioritized files (that is,\n      // files that have been changed at least once) at a higher frequency\n      // (every 500ms by default).\n      return NO_WATCHER_POLLING_INTERVAL;\n    }\n\n    if (WATCHER_ENABLED || PRIORITIZE_CHANGED) {\n      // As long as native file watching is enabled (even if it doesn't\n      // work correctly) and the developer hasn't explicitly opted out of\n      // the file watching priority system, poll unchanged files at a\n      // lower frequency (every 5000ms by default).\n      return DEFAULT_POLLING_INTERVAL;\n    }\n\n    // If native file watching is disabled and the developer has\n    // explicitly opted out of the priority system, poll everything at the\n    // higher frequency (every 500ms by default). Note that this leads to\n    // higher idle CPU usage, so the developer may want to adjust the\n    // METEOR_WATCH_POLLING_INTERVAL_MS environment variable.\n    return NO_WATCHER_POLLING_INTERVAL;\n  }\n\n  function fire(event) {\n    if (event !== \"change\") {\n      // When we receive a \"delete\" or \"rename\" event, the watcher is\n      // probably not going to generate any more notifications for this\n      // file, so we close and nullify the watcher to ensure that\n      // entry.rewatch() will attempt to reestablish the watcher the next\n      // time we call safeWatcher.watch.\n      safeUnwatch();\n\n      // Make sure we don't throttle the watchFile callback after a\n      // \"delete\" or \"rename\" event, since it is now our only reliable\n      // source of file change notifications.\n      lastWatcherEventTime = 0;\n\n    } else {\n      changedPaths.add(absPath);\n      rewatch();\n    }\n\n    callbacks.forEach(cb => cb.call(this, event));\n  }\n\n  function watchWrapper(event) {\n    lastWatcherEventTime = +new Date;\n    fire.call(this, event);\n\n    // It's tempting to call unwatchFile(absPath, watchFileWrapper) here,\n    // but previous watcher success is no guarantee of future watcher\n    // reliability. For example, watchLibrary.watch works just fine when file\n    // changes originate from within a Vagrant VM, but changes to shared\n    // files made outside the VM are invisible to watcher, so our only\n    // hope of catching them is to continue polling.\n  }\n\n  function rewatch() {\n    if (hasPriority(absPath)) {\n      if (watcher) {\n        // Already watching; nothing to do.\n        return;\n      }\n      watcher = watchLibraryWatch(absPath, watchWrapper);\n    } else if (watcher) {\n      safeUnwatch();\n    }\n\n    // Since we're about to restart the stat-based file watcher, we don't\n    // want to miss any of its events because of the lastWatcherEventTime\n    // throttling that it attempts to do.\n    lastWatcherEventTime = 0;\n\n    // We use files.watchFile in addition to watcher.watch as a fail-safe\n    // to detect file changes even on network file systems.  However\n    // (unless the user disabled watcher or this watcher call failed), we\n    // use a relatively long default polling interval of 5000ms to save\n    // CPU cycles.\n    statWatch(absPath, getPollingInterval(), watchFileWrapper);\n  }\n\n  function watchFileWrapper(...args) {\n    const [newStat, oldStat] = args;\n\n    if (newStat.ino === 0 &&\n        oldStat.ino === 0 &&\n        +newStat.mtime === +oldStat.mtime) {\n      // Node calls the watchFile listener once with bogus identical stat\n      // objects, which should not trigger a file change event.\n      return;\n    }\n\n    // If a watcher event fired in the last polling interval, ignore\n    // this event.\n    if (new Date - lastWatcherEventTime > getPollingInterval()) {\n      fire.call(this, \"change\");\n    }\n  }\n\n  const entry = {\n    callbacks,\n    rewatch,\n\n    release(callback) {\n      if (! entries[absPath]) {\n        return;\n      }\n\n      callbacks.delete(callback);\n      if (callbacks.size > 0) {\n        return;\n      }\n\n      // Once there are no more callbacks in the Set, close both watchers\n      // and nullify the shared data.\n      clearTimeout(watcherCleanupTimer);\n      watcherCleanupTimer = setTimeout(() => {\n        if (callbacks.size > 0) {\n          // If another callback was added while the timer was pending, we\n          // can avoid tearing anything down.\n          return;\n        }\n        entry.close();\n      }, WATCHER_CLEANUP_DELAY_MS);\n    },\n\n    close() {\n      if (entries[absPath] !== entry) return;\n      entries[absPath] = null;\n\n      if (watcherCleanupTimer) {\n        clearTimeout(watcherCleanupTimer);\n        watcherCleanupTimer = null;\n      }\n\n      safeUnwatch();\n\n      unwatchFile(absPath, watchFileWrapper);\n    }\n  };\n\n  if (ino > 0) {\n    entriesByIno.set(ino, entry);\n  }\n\n  return entry;\n}\n\nexport function closeAllWatchers() {\n  Object.keys(entries).forEach(absPath => {\n    const entry = entries[absPath];\n    if (entry) {\n      entry.close();\n    }\n  });\n}\n\nconst statWatchers = Object.create(null);\n\nfunction statWatch(absPath, interval, callback) {\n  const oldWatcher = statWatchers[absPath];\n\n  while (oldWatcher) {\n    // Make sure this callback no longer appears among the listeners for\n    // this StatWatcher.\n    const countBefore = oldWatcher.stat.listenerCount(\"change\");\n\n    // This removes at most one occurrence of the callback from the\n    // listeners list...\n    oldWatcher.stat.removeListener(\"change\", callback);\n\n    // ... so we have to keep calling it until the first time\n    // it removes nothing.\n    if (oldWatcher.stat.listenerCount(\"change\") === countBefore) {\n      break;\n    }\n  }\n\n  // This doesn't actually call newStat.start again if there's already a\n  // watcher for this file, so it won't change any interval previously\n  // specified. In the rare event that the interval needs to change, we\n  // manually stop and restart the StatWatcher below.\n  const newStat = watchFile(absPath, {\n    persistent: false, // never persistent\n    interval,\n  }, callback);\n\n  if (! oldWatcher) {\n    const newWatcher = {\n      stat: newStat,\n      interval,\n    };\n\n    newStat.on(\"stop\", () => {\n      if (statWatchers[absPath] === newWatcher) {\n        delete statWatchers[absPath];\n      }\n    });\n\n    return statWatchers[absPath] = newWatcher;\n  }\n\n  // These should be identical at this point, but just in case.\n  oldWatcher.stat = newStat;\n\n  // If the interval needs to be changed, manually stop and restart the\n  // StatWatcher using lower-level methods than unwatchFile and watchFile.\n  if (oldWatcher.interval !== interval) {\n    oldWatcher.stat.stop();\n    oldWatcher.stat.start(\n      convertToOSPath(pathResolve(absPath)),\n      false, // never persistent\n      oldWatcher.interval = interval,\n    );\n  }\n\n  return oldWatcher;\n}\n\nfunction watchLibraryWatch(absPath, callback) {\n  if (WATCHER_ENABLED) {\n    try {\n      return watchLibrary.watch(convertToOSPath(absPath), callback);\n    } catch (e) {\n      maybeSuggestRaisingWatchLimit(e);\n      // ... ignore the error.  We'll still have watchFile, which is good\n      // enough.\n    }\n  }\n\n  return null;\n}\n\nlet suggestedRaisingWatchLimit = false;\n\n// This function is async so that archinfo.host() (which may call\n// utils.execFileSync) will run in a Fiber.\nasync function maybeSuggestRaisingWatchLimit(error) {\n  var constants = require('constants');\n  var archinfo = require('../utils/archinfo.js');\n  if (! suggestedRaisingWatchLimit &&\n      // Note: the not-super-documented require('constants') maps from\n      // strings to SYSTEM errno values. System errno values aren't the same\n      // as the numbers used internally by libuv! Once we're upgraded\n      // to Node 0.12, we'll have the system errno as a string (on 'code'),\n      // but the support for that wasn't in Node 0.10's uv.\n      // See our PR https://github.com/atom/node-pathwatcher/pull/53\n      // (and make sure to read the final commit message, not the original\n      // proposed PR, which had a slightly different interface).\n      error.errno === constants.ENOSPC &&\n      // The only suggestion we currently have is for Linux.\n      archinfo.matches(archinfo.host(), 'os.linux')) {\n\n    // Check suggestedRaisingWatchLimit again because archinfo.host() may\n    // have yielded.\n    if (suggestedRaisingWatchLimit) return;\n    suggestedRaisingWatchLimit = true;\n\n    var Console = require('../console/console.js').Console;\n    if (! Console.isHeadless()) {\n      Console.arrowWarn(\n        \"It looks like a simple tweak to your system's configuration will \" +\n          \"make many tools (including this Meteor command) more efficient. \" +\n          \"To learn more, see \" +\n          Console.url(\"https://github.com/meteor/meteor/wiki/File-Change-Watcher-Efficiency\"));\n    }\n  }\n}\n\nexport const watch = Profile(\n  \"safeWatcher.watch\",\n  (absPath, callback) => {\n    const entry = acquireWatcher(absPath, callback);\n    return {\n      close() {\n        entry.release(callback);\n      }\n    };\n  }\n);\n"]}