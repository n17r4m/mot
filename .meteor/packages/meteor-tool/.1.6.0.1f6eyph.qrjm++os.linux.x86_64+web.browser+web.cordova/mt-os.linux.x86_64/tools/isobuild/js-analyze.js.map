{"version":3,"sources":["/tools/isobuild/js-analyze.js"],"names":["module1","module","export","findImportedModuleIdentifiers","findAssignedGlobals","parse","watch","require","v","analyzeScope","analyze","LRU","default","hasOwn","Object","prototype","hasOwnProperty","AST_CACHE","max","Math","pow","length","ast","loc","end","line","tryToParse","source","hash","has","get","e","$ParseError","set","dependencyKeywordPattern","identifiers","possibleIndexes","match","lastIndex","exec","push","index","walk","node","left","right","requireIsBound","Array","isArray","i","len","isNode","start","isFunctionWithParameter","id","getRequiredModuleId","addIdentifier","importInfo","getImportedModuleInfo","dynamic","key","keys","type","isDynamic","entry","call","possiblySpurious","value","isIdWithName","name","params","some","param","callee","args","arguments","argc","arg","isStringLiteral","firstArg","object","propertyName","isPropertyWithName","property","globalsCache","globals","sum","forEach","scopeManager","ecmaVersion","sourceType","ignoreEval","nodejsScope","program","programScope","acquire","assignedGlobals","implicit","variables","variable","identifier","writeExpr"],"mappings":"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","file":"tools/isobuild/js-analyze.js.map","sourcesContent":["import { parse } from 'meteor-babel';\nimport { analyze as analyzeScope } from 'escope';\nimport LRU from \"lru-cache\";\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nvar AST_CACHE = new LRU({\n  max: Math.pow(2, 12),\n  length(ast) {\n    return ast.loc.end.line;\n  }\n});\n\n// Like babel.parse, but annotates any thrown error with $ParseError = true.\nfunction tryToParse(source, hash) {\n  if (hash && AST_CACHE.has(hash)) {\n    return AST_CACHE.get(hash);\n  }\n\n  let ast;\n\n  try {\n    ast = parse(source);\n  } catch (e) {\n    if (typeof e.loc === 'object') {\n      e.$ParseError = true;\n    }\n    throw e;\n  }\n\n  if (hash) {\n    AST_CACHE.set(hash, ast);\n  }\n\n  return ast;\n}\n\nvar dependencyKeywordPattern =\n  /\\b(?:require|import|importSync|dynamicImport|export)\\b/g;\n\n/**\n * The `findImportedModuleIdentifiers` function takes a string of module\n * source code and returns a map from imported module identifiers to AST\n * nodes. The keys of this map are used in ./import-scanner.js to traverse\n * the module dependency graph. The AST nodes are generally ignored.\n *\n * The implementation uses a regular expression to scan quickly for\n * possible locations of certain tokens (`require`, `import`, `export`),\n * then uses that location information to steer the AST traversal, so that\n * it visits only subtrees that contain interesting tokens, saving a lot\n * of time by ignoring the rest of the AST. The AST traversal determines\n * if the tokens were actually what we thought they were (a `require`\n * function call, or an `import` or `export` statement).\n */\nexport function findImportedModuleIdentifiers(source, hash) {\n  const identifiers = {};\n  const possibleIndexes = [];\n  let match;\n\n  dependencyKeywordPattern.lastIndex = 0;\n  while ((match = dependencyKeywordPattern.exec(source))) {\n    possibleIndexes.push(match.index);\n  }\n\n  if (!possibleIndexes.length) {\n    return {};\n  }\n\n  const ast = tryToParse(source, hash);\n\n  function walk(node, left, right, requireIsBound) {\n    if (left >= right) {\n      // The window of possible indexes is empty, so we can ignore\n      // the entire subtree rooted at this node.\n    } else if (Array.isArray(node)) {\n      for (var i = 0, len = node.length; i < len; ++i) {\n        walk(node[i], left, right, requireIsBound);\n      }\n    } else if (isNode(node)) {\n      const start = node.start;\n      const end = node.end;\n\n      // Narrow the left-right window to exclude possible indexes\n      // that fall outside of the current node.\n      while (left < right && possibleIndexes[left] < start) ++left;\n      while (left < right && end < possibleIndexes[right - 1]) --right;\n\n      if (left < right) {\n        if (! requireIsBound &&\n            isFunctionWithParameter(node, \"require\")) {\n          requireIsBound = true;\n        }\n\n        let id = getRequiredModuleId(node);\n        if (typeof id === \"string\") {\n          return addIdentifier(id, \"require\", requireIsBound);\n        }\n\n        const importInfo = getImportedModuleInfo(node);\n        if (importInfo) {\n          return addIdentifier(\n            importInfo.id,\n            \"import\",\n            requireIsBound,\n            importInfo.dynamic\n          );\n        }\n\n        // Continue traversing the children of this node.\n        for (const key of Object.keys(node)) {\n          switch (key) {\n          case \"type\":\n          case \"loc\":\n          case \"start\":\n          case \"end\":\n            // Ignore common keys that are never nodes.\n            continue;\n          }\n\n          walk(node[key], left, right, requireIsBound);\n        }\n      }\n    }\n  }\n\n  function addIdentifier(id, type, requireIsBound, isDynamic) {\n    const entry = hasOwn.call(identifiers, id)\n      ? identifiers[id]\n      : identifiers[id] = {\n          possiblySpurious: true,\n          dynamic: !! isDynamic\n        };\n\n    if (! isDynamic) {\n      entry.dynamic = false;\n    }\n\n    if (type === \"require\") {\n      // If the identifier comes from a require call, but require is not a\n      // free variable, then this dependency might be spurious.\n      entry.possiblySpurious =\n        entry.possiblySpurious && requireIsBound;\n    } else {\n      // The import keyword can't be shadowed, so any dependencies\n      // registered by import statements should be trusted absolutely.\n      entry.possiblySpurious = false;\n    }\n  }\n\n  walk(ast, 0, possibleIndexes.length, false);\n\n  return identifiers;\n}\n\nfunction isNode(value) {\n  return value\n    && typeof value === \"object\"\n    && typeof value.type === \"string\"\n    && typeof value.start === \"number\"\n    && typeof value.end === \"number\";\n}\n\nfunction isIdWithName(node, name) {\n  return node &&\n    node.type === \"Identifier\" &&\n    node.name === name;\n}\n\nfunction isFunctionWithParameter(node, name) {\n  if (node.type === \"FunctionExpression\" ||\n      node.type === \"FunctionDeclaration\" ||\n      node.type === \"ArrowFunctionExpression\") {\n    return node.params.some(param => isIdWithName(param, name));\n  }\n}\n\nfunction getRequiredModuleId(node) {\n  if (node.type === \"CallExpression\" &&\n      isIdWithName(node.callee, \"require\")) {\n    const args = node.arguments;\n    const argc = args.length;\n    if (argc > 0) {\n      const arg = args[0];\n      if (isStringLiteral(arg)) {\n        return arg.value;\n      }\n    }\n  }\n}\n\nfunction isStringLiteral(node) {\n  return node && (\n    node.type === \"StringLiteral\" ||\n    (node.type === \"Literal\" &&\n     typeof node.value === \"string\"));\n}\n\nfunction getImportedModuleInfo(node) {\n  switch (node.type) {\n  case \"CallExpression\":\n    if (node.callee.type === \"Import\" ||\n        isIdWithName(node.callee, \"import\")) {\n      const firstArg = node.arguments[0];\n      if (isStringLiteral(firstArg)) {\n        return {\n          id: firstArg.value,\n          dynamic: true,\n        };\n      }\n\n    } else if (node.callee.type === \"MemberExpression\" &&\n               isIdWithName(node.callee.object, \"module\")) {\n      const propertyName =\n        isPropertyWithName(node.callee.property, \"import\") ||\n        isPropertyWithName(node.callee.property, \"importSync\") ||\n        isPropertyWithName(node.callee.property, \"dynamicImport\");\n\n      if (propertyName) {\n        const dynamic = propertyName === \"dynamicImport\";\n        const args = node.arguments;\n        const argc = args.length;\n\n        if (argc > 0) {\n          const arg = args[0];\n          if (isStringLiteral(arg)) {\n            return {\n              id: arg.value,\n              dynamic,\n            };\n          }\n        }\n      }\n    }\n\n    return null;\n\n  case \"ImportDeclaration\":\n  case \"ExportAllDeclaration\":\n  case \"ExportNamedDeclaration\":\n    // The .source of an ImportDeclaration or Export{Named,All}Declaration\n    // is always a string-valued Literal node, if not null.\n    if (isNode(node.source)) {\n      return {\n        id: node.source.value,\n        dynamic: false,\n      };\n    }\n\n    return null;\n  }\n}\n\nfunction isPropertyWithName(node, name) {\n  if (isIdWithName(node, name) ||\n      (isStringLiteral(node) &&\n       node.value === name)) {\n    return name;\n  }\n}\n\n// Analyze the JavaScript source code `source` and return a dictionary of all\n// globals which are assigned to in the package. The values in the dictionary\n// are all `true`.\n//\n// This is intended for use in detecting package-scope variables in Meteor\n// packages, where the linker needs to add a \"var\" statement to prevent them\n// from staying as globals.\n//\n// It only cares about assignments to variables; an assignment to a field on an\n// object (`Foo.Bar = true`) neither causes `Foo` nor `Foo.Bar` to be returned.\nconst globalsCache = new LRU({\n  max: Math.pow(2, 12),\n  length(globals) {\n    let sum = 0;\n    Object.keys(globals).forEach(name => sum += name.length);\n    return sum;\n  }\n});\n\nexport function findAssignedGlobals(source, hash) {\n  if (hash && globalsCache.has(hash)) {\n    return globalsCache.get(hash);\n  }\n\n  const ast = tryToParse(source, hash);\n\n  // We have to pass ignoreEval; otherwise, the existence of a direct eval call\n  // causes escope to not bother to resolve references in the eval's scope.\n  // This is because an eval can pull references inward:\n  //\n  //   function outer() {\n  //     var i = 42;\n  //     function inner() {\n  //       eval('var i = 0');\n  //       i;  // 0, not 42\n  //     }\n  //   }\n  //\n  // But it can't pull references outward, so for our purposes it is safe to\n  // ignore.\n  const scopeManager = analyzeScope(ast, {\n    ecmaVersion: 6,\n    sourceType: \"module\",\n    ignoreEval: true,\n    // Ensures we don't treat top-level var declarations as globals.\n    nodejsScope: true,\n  });\n\n  const program = ast.type === \"File\" ? ast.program : ast;\n  const programScope = scopeManager.acquire(program);\n  const assignedGlobals = {};\n\n  // Passing {sourceType: \"module\"} to analyzeScope leaves this list\n  // strangely empty, but {sourceType: \"script\"} forbids ImportDeclaration\n  // nodes (because they are only legal in modules.\n  programScope.implicit.variables.forEach(variable => {\n    assignedGlobals[variable.name] = true;\n  });\n\n  // Fortunately, even with {sourceType: \"module\"}, the .implicit.left\n  // array still has all the information we need, as long as we ignore\n  // global variable references that are not assignments.\n  programScope.implicit.left.forEach(entry => {\n    if (entry.identifier &&\n        entry.identifier.type === \"Identifier\" &&\n        // Only consider identifers that are assigned a value.\n        entry.writeExpr) {\n      assignedGlobals[entry.identifier.name] = true;\n    }\n  });\n\n  if (hash) {\n    globalsCache.set(hash, assignedGlobals);\n  }\n\n  return assignedGlobals;\n}\n"]}