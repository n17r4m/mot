{"version":3,"sources":["/tools/utils/parse-stack.js"],"names":["module","export","parse","markBottom","markTop","_","require","err","frames","stack","split","slice","filter","f","match","indexOfFiberSplit","indexOf","outsideFiber","parseStackFrames","insideFiber","__bottom_mark__","apply","arguments","__top_mark__","stop","ret","some","frame","m","push","func","file","line","undefined","column","startsWith","isEmpty","Error"],"mappings":"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","file":"tools/utils/parse-stack.js.map","sourcesContent":["const _ = require('underscore');\n\n// Given an Error (eg, 'new Error'), return the stack associated with\n// that error as an array. More recently called functions appear first\n// and each element is an object with keys:\n// - file: filename as it appears in the stack\n// - line: 1-indexed line number in file, as a Number\n// - column: 1-indexed column in line, as a Number\n// - func: name of the function in the frame (maybe null)\n//\n// Accomplishes this by parsing the text representation of the stack\n// with regular expressions. Unlikely to work anywhere but v8.\n//\n// If a function on the stack has been marked with mark(), don't\n// return anything past that function. We call this the \"user portion\"\n// of the stack.\nexport function parse(err) {\n  // at least the first line is the exception\n  const frames = err.stack.split(\"\\n\").slice(1)\n    // longjohn adds lines of the form '---' (45 times) to separate\n    // the trace across async boundaries. It's not clear if we need to\n    // separate the trace in the same way we do for future boundaries below\n    // (it's not clear that that code is still useful either)\n    // so for now, we'll just remove such lines\n    .filter(f => ! f.match(/^\\-{45}$/));\n  \n  // \"    - - - - -\"\n  // This is something added when you throw an Error through a Future. The\n  // stack above the dashes is the stack of the 'wait' call; the stack below\n  // is the stack inside the fiber where the Error is originally\n  // constructed.\n  // XXX This code assumes that the stack trace can only be split once. It's not\n  // clear whether this can happen multiple times.\n  const indexOfFiberSplit = frames.indexOf('    - - - - -');\n\n  if (indexOfFiberSplit === -1) {\n    // This is a normal stack trace, not a split fiber stack trace\n    return {\n      outsideFiber: parseStackFrames(frames)\n    }\n  }\n\n  // If this is a split stack trace from a future, parse the frames above and\n  // below the split separately.\n  const outsideFiber = parseStackFrames(frames);\n  const insideFiber = parseStackFrames(frames.slice(indexOfFiberSplit + 1));\n\n  return {\n    insideFiber,\n    outsideFiber\n  };\n}\n\n// Decorator. Mark the point at which a stack trace returned by\n// parse() should stop: no frames earlier than this point will be\n// included in the parsed stack. Confusingly, in the argot of the\n// times, you'd say that frames \"higher up\" than this or \"above\" this\n// will not be returned, but you'd also say that those frames are \"at\n// the bottom of the stack\". Frames below the bottom are the outer\n// context of the framework running the user's code.\nexport function markBottom(f) {\n  /* eslint-disable camelcase */\n  return function __bottom_mark__() {\n    return f.apply(this, arguments);\n  };\n  /* eslint-enable camelcase */\n}\n\n// Decorator. Mark the point at which a stack trace returned by\n// parse() should begin: no frames later than this point will be\n// included in the parsed stack. The opposite of markBottom().\n// Frames above the top are helper functions defined by the\n// framework and executed by user code whose internal behavior\n// should not be exposed.\nexport function markTop(f) {\n  /* eslint-disable camelcase */\n  return function __top_mark__() {\n    return f.apply(this, arguments);\n  };\n  /* eslint-enable camelcase */\n}\n\nfunction parseStackFrames(frames) {\n  let stop = false;\n  let ret = [];\n  frames.some(frame => {\n    if (stop) {\n      return true;\n    }\n\n    let m;\n\n    /* eslint-disable max-len */\n    if (m = frame.match(/^\\s*at\\s*((new )?.+?)\\s*(\\[as\\s*([^\\]]*)\\]\\s*)?\\((.*?)(:(\\d+))?(:(\\d+))?\\)\\s*$/)) {\n      // https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n      // \"    at My.Function (/path/to/myfile.js:532:39)\"\n      // \"    at Array.forEach (native)\"\n      // \"    at new My.Class (file.js:1:2)\"\n      // \"    at [object Object].main.registerCommand.name [as func] (meteor/tools/commands.js:1225:19)\"\n      // \"    at __top_mark__ [as matchErr] (meteor/tools/parse-stack.js:82:14)\"\n      //\n      // In that last example, it is not at all clear to me what the\n      // 'as' stanza refers to, but it is in m[3] if you find a use for it.\n      if (m[1].match(/(?:^|\\.)__top_mark__$/)) {\n        // m[1] could be Object.__top_mark__ or something like that\n        // depending on where exactly you put the function returned by\n        // markTop\n        ret = [];\n        return;\n      }\n      if (m[1].match(/(?:^|\\.)__bottom_mark__$/)) {\n        return stop = true;\n      }\n      ret.push({\n        func: m[1],\n        file: m[5],\n        line: m[7] ? +m[7] : undefined,\n        column: m[9] ? +m[9] : undefined\n      });\n      return;\n    }\n    /* eslint-enable max-len */\n\n    if (m = frame.match(/^\\s*at\\s+(.+?)(:(\\d+))?(:(\\d+))?\\s*$/)) {\n      // \"    at /path/to/myfile.js:532:39\"\n      ret.push({\n        file: m[1],\n        line: m[3] ? +m[3] : undefined,\n        column: m[5] ? +m[5] : undefined\n      });\n      return;\n    }\n\n    if (m = frame.match(/^\\s*-\\s*-\\s*-\\s*-\\s*-\\s*$/)) {\n      // Stop parsing if we reach a stack split from a Future\n      return stop = true;\n    }\n\n    if (frame.startsWith(\" => awaited here:\")) {\n      // The meteor-promise library inserts \" => awaited here:\" lines to\n      // indicate async boundaries.\n      return stop = true;\n    }\n\n    if (_.isEmpty(ret)) {\n      // We haven't found any stack frames, so probably we have newlines in the\n      // error message. Just skip this line.\n      return;\n    }\n\n    throw new Error(\"Couldn't parse stack frame: '\" + frame + \"'\");\n  });\n\n  return ret;\n}\n"]}