{"version":3,"sources":["/tools/utils/processes.js"],"names":["module","export","execFileSync","execFileAsync","_","watch","require","default","v","child_process","files","command","args","options","Promise","await","waitForClose","Array","isArray","extend","cwd","convertToOSPath","exitEvent","resolve","reject","child","process","platform","spawn","env","stdio","forEach","arg","exec","capturedStdout","stdout","destination","pipe","setEncoding","on","data","capturedStderr","stderr","errorCallback","error","removeListener","exitCallback","trim","pid","code","message","signal","errorMessage","join","Error","status"],"mappings":"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","file":"tools/utils/processes.js.map","sourcesContent":["import _ from 'underscore';\nimport child_process from 'child_process';\nimport files from '../fs/mini-files';\n\n// The execFileSync function is meant to resemble the similarly-named Node 0.12\n// synchronous process creation API, but instead of being fully blocking it\n// uses a promise-based implementation. You can also use\n// execFileAsync directly, which returns a promise.\n// Some functionality is currently missing but could be added when the need\n// arises (e.g. support for timeout, maxBuffer, and encoding options).\n// Eventually, these versions should replace the ones in tools/utils/utils.js\n// and tools/tool-testing/selftest.js.\n\n/**\n * @summary Executes a command synchronously, returning either the captured\n * stdout output or throwing an error containing the stderr output as part of\n * the message. In addition, the error will contain fields pid, stderr, stdout,\n * status and signal.\n * @param {String} command The command to run\n * @param {Array} [args] List of string arguments\n * @param {Object} [options]\n * @param {Object} [options.cwd] Current working directory of the child process\n * @param {Object} [options.env] Environment key-value pairs\n * @param {Array|String} [options.stdio] Child's stdio configuration.\n * (Default: 'pipe') Specifying anything else than 'pipe' will disallow\n * capture.\n * @param {Writable} [options.destination] If specified, instead of capturing\n * the output, the child process stdout will be piped to the destination stream.\n * @param {String} [options.waitForClose] Whether to wait for the child process\n * streams to close or to resolve the promise when the child process exits.\n * @returns {String} The stdout from the command\n */\nexport function execFileSync(command, args, options) {\n  return Promise.await(execFileAsync(command, args, options));\n}\n\n/**\n * @summary Executes a command asynchronously, returning a promise that will\n * either be resolved to the captured stdout output or be rejected with an\n * error containing the stderr output as part of the message. In addition,\n * the error will contain fields pid, stderr, stdout, status and signal.\n * @param {String} command The command to run\n * @param {Array} [args] List of string arguments\n * @param {Object} [options]\n * @param {Object} [options.cwd] Current working directory of the child process\n * @param {Object} [options.env] Environment key-value pairs\n * @param {Array|String} [options.stdio] Child's stdio configuration.\n * (Default: 'pipe') Specifying anything else than 'pipe' will disallow\n * capture.\n * @param {Writable} [options.destination] If specified, instead of capturing\n * the output, the child process stdout will be piped to the destination stream.\n * @param {String} [options.waitForClose] Whether to wait for the child process\n * streams to close or to resolve the promise when the child process exits.\n * @returns {Promise<String>}\n */\nexport function execFileAsync(command, args,\n  options = { waitForClose: true }) {\n  // args is optional, so if it's not an array we interpret it as options\n  if (!Array.isArray(args)) {\n    options = _.extend(options, args);\n    args = [];\n  }\n  if (options.cwd) {\n    options.cwd = files.convertToOSPath(options.cwd);\n  }\n  // The child process close event is emitted when the stdio streams\n  // have all terminated. If those streams are shared with other\n  // processes, that means we won't receive a 'close' until all processes\n  // have exited, so we may want to respond to 'exit' instead.\n  // (The downside of responding to 'exit' is that the streams may not be\n  // fully flushed, so we could miss captured output. Only use this\n  // option when needed.)\n  const exitEvent = options.waitForClose ? 'close' : 'exit';\n\n  return new Promise((resolve, reject) => {\n    var child; \n\n    if (process.platform !== 'win32') {\n      child = child_process.spawn(command, args,\n      { cwd, env, stdio } = options);\n    } else {\n      // https://github.com/nodejs/node-v0.x-archive/issues/2318\n      args.forEach(arg => {\n        command += ' ' + arg;\n      });\n      child = child_process.exec(command,\n      { cwd, env, stdio } = options);\n    }\n\n    let capturedStdout = '';\n    if (child.stdout) {\n      if (options.destination) {\n        child.stdout.pipe(options.destination);\n      } else {\n        child.stdout.setEncoding('utf8');\n        child.stdout.on('data', (data) => {\n          capturedStdout += data;\n        });\n      }\n    }\n\n    let capturedStderr = '';\n    if (child.stderr) {\n      child.stderr.setEncoding('utf8');\n      child.stderr.on('data', (data) => {\n        capturedStderr += data;\n      });\n    }\n\n    const errorCallback = (error) => {\n      // Make sure we only receive one type of callback\n      child.removeListener(exitEvent, exitCallback);\n\n      // Trim captured output to get rid of excess whitespace\n      capturedStdout = capturedStdout.trim();\n      capturedStderr = capturedStderr.trim();\n\n      _.extend(error, {\n        pid: child.pid,\n        stdout: capturedStdout,\n        stderr: capturedStderr,\n      });\n\n      // Set a more informative error message on ENOENT, that includes the\n      // command we attempted to execute\n      if (error.code === 'ENOENT') {\n        error.message = `Could not find command '${command}'`;\n      }\n\n      reject(error);\n    };\n    child.on('error', errorCallback);\n\n    const exitCallback = (code, signal) => {\n      // Make sure we only receive one type of callback\n      child.removeListener('error', errorCallback);\n\n      // Trim captured output to get rid of excess whitespace\n      capturedStdout = capturedStdout.trim();\n      capturedStderr = capturedStderr.trim();\n\n      if (code === 0) {\n        resolve(capturedStdout);\n      } else {\n        let errorMessage = `Command failed: ${command}`;\n        if (args) {\n          errorMessage += ` ${args.join(' ')}`;\n        }\n        errorMessage += `\\n${capturedStderr}`;\n\n        const error = new Error(errorMessage);\n\n        _.extend(error, {\n          pid: child.pid,\n          stdout: capturedStdout,\n          stderr: capturedStderr,\n          status: code,\n          signal: signal\n        });\n\n        reject(error);\n      }\n    };\n    child.on(exitEvent, exitCallback);\n  });\n}\n"]}