{"version":3,"sources":["/tools/fs/files.js"],"names":["module1","module","export","dependOnPath","assert","require","fs","path","os","util","_","Fiber","crypto","spawn","rimraf","sourcemap","sourceMapRetrieverStack","utils","cleanup","buildmessage","fiberHelpers","colonConverter","miniFiles","Profile","files","exports","extend","parsedSourceMaps","nextStackFilenameCounter","useParsedSourceMap","pathForSourceMap","has","map","push","YIELD_ALLOWED","process","env","JSON","parse","METEOR_DISABLE_FS_FIBERS","canYield","current","yield","disallowed","mayYield","findUpwards","predicate","startPath","testDir","cwd","newDir","pathDirname","convertToStandardPath","findAppDir","filepath","isAppDir","stat","pathJoin","isFile","e","findPackageDir","isPackageDir","addToGitignore","dirPath","entry","exists","data","readFile","lines","split","any","x","substr","writeFile","inCheckout","once","getCurrentToolsDir","console","log","usesWarehouse","METEOR_WAREHOUSE_DIR","getToolsVersion","isopackJsonPath","parsed","isopackJson","name","version","unipackageJsonPath","unipackageJson","Error","getDevBundle","getCurrentNodeBinDir","__dirname","getSettings","filename","watchSet","assertInCapture","absPath","pathResolve","buffer","readAndWatchFile","error","file","length","str","toString","match","prettyPath","p","realpath","home","getHomeDir","relativeToHome","pathRelative","pathSep","statOrNull","preserveSymlinks","lstat","code","rm_recursive_async","Promise","resolve","reject","convertToOSPath","err","rm_recursive","sync","await","fileHash","hash","createHash","setEncoding","rs","createReadStream","on","close","digest","pipe","end","blankHash","treeHash","root","options","ignore","relativePath","hashLog","TREE_HASH_DEBUG","updateHash","text","update","traverse","stringify","isDirectory","each","readdir","size","mode","isSymbolicLink","readlink","appendFile","join","mkdir_p","dir","ps","pathNormalize","parentPath","slice","success","pathIsDirectory","mkdir","cp_r","from","to","forEach","f","pattern","fullFrom","transformFilename","symlink","transformContents","pathBasename","copyFileHelper","getPathsInDir","noYieldsAllowed","absoluteDir","output","newPath","newAbsPath","findPathsWithRegex","regex","allPaths","filter","copyFile","origMode","stats","readStream","writeStream","createWriteStream","tempDirs","Object","create","mkdtemp","prefix","make","tmpDir","first","t","identity","platform","tries","Math","random","freeTempDir","METEOR_SAVE_TMPDIRS","then","onExit","sig","keys","extractTarGz","destPath","parentDir","tempDir","randomToken","verbose","Console","startTime","Date","promise","tryExtractWithNative7z","tryExtractWithNativeTar","catch","tryExtractWithNpmTar","topLevelOfArchive","startsWith","extractDir","rename","ensureDirectoryEmpty","forceConvert","flags","tarProc","stdio","stdout","stderr","stdin","write","exeOSPath","tarGzBasename","spawnOptions","strictEqual","tarBasename","foundTar","some","ok","cleanUp","unlink","tar","zlib","gunzip","createGunzip","extractor","Extract","convert","addExecBitWhenReadBitPresent","fileMode","createTarGzStream","fstream","binPathMatch","sep","fileStream","Reader","type","props","indexOf","tarStream","Pack","noProprietary","createGzip","createTarball","tarball","out","renameDirAlmostAtomically","fromDir","toDir","garbageDir","cleanupGarbage","forceCopy","writeFileAtomically","contents","tmpFile","symlinkOverSync","linkText","tmpSymlink","runJavaScript","time","values","symbols","value","stackFilename","sourceMap","chunks","header","consumer","SourceMapConsumer","SourceNode","fromStringWithSourceMap","wrapped","parsedSourceMap","node","results","toStringWithSourceMap","toJSON","sourceMapRoot","sourceRoot","sourcesContent","script","createScript","nodeParseError","SyntaxError","strictMode","parseError","loc","FancySyntaxError","message","consumer2","original","originalPositionFor","source","line","column","func","runInThisContext","markBoundary","apply","OfflineError","prototype","readdirNoDots","entries","getLines","splitBufferToLines","pop","getLinesOrEmpty","readJSONOrNull","raw","trimSpaceAndComments","trimSpace","replace","KeyValueFile","self","set","k","v","_readAll","found","i","trimmed","trim","newdata","METEOR_INSTALLATION","HOME","currentEnvWithPathsAdded","paths","pathPropertyName","find","key","toUpperCase","convertedPaths","pathDecomposed","pathOsDelimiter","unshift","ensureBatExtension","_generateScriptLinkToMeteorScript","scriptLocation","scriptLocationIsAbsolutePath","scriptLocationConverted","convertToWindowsPath","newScript","EOL","_getLocationFromScriptLinkToMeteorScript","compact","last","isAbsolute","convertToPosixPath","linkToMeteorScript","linkLocation","encoding","readLinkToMeteorScript","fsFixPath","wrapFsFunc","fsFuncName","pathArgIndices","fsFunc","fsFuncSync","makeWrapper","alwaysSync","wrapper","args","j","shouldBeSync","isQuickie","dirty","dirtyFn","noErr","result","modifyReturnValue","cb","res","displayName","dependOnPathSalt","wrap","wrapDestructiveFsFunc","fileData","isString","convertToStandardLineEndings","withCacheCache","withCache","fn","oldCache","enableCache","method","makeCacheKey","parts","arg","cacheKey","existsSync","callback","isWindowsLikeFilesystem","maxTries","osTo","watchFile","unwatchFile","readBufferWithLengthAndOffset","offset","Buffer","fd","open","count","read"],"mappings":"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","file":"tools/fs/files.js.map","sourcesContent":["///\n/// utility functions for files and directories. includes both generic\n/// helper functions (such as rm_recursive), and meteor-specific ones\n/// (such as testing whether an directory is a meteor app)\n///\n\nvar assert = require(\"assert\");\nvar fs = require(\"fs\");\nvar path = require('path');\nvar os = require('os');\nvar util = require('util');\nvar _ = require('underscore');\nvar Fiber = require('fibers');\nvar crypto = require('crypto');\nvar spawn = require(\"child_process\").spawn;\n\nvar rimraf = require('rimraf');\nvar sourcemap = require('source-map');\nvar sourceMapRetrieverStack = require('../tool-env/source-map-retriever-stack.js');\n\nvar utils = require('../utils/utils.js');\nvar cleanup = require('../tool-env/cleanup.js');\nvar buildmessage = require('../utils/buildmessage.js');\nvar fiberHelpers = require('../utils/fiber-helpers.js');\nvar colonConverter = require('../utils/colon-converter.js');\n\nvar miniFiles = require('./mini-files.js');\n\nvar Profile = require('../tool-env/profile.js').Profile;\n\n// Attach all exports of miniFiles here to avoid code duplication\nvar files = exports;\n_.extend(files, miniFiles);\n\nvar parsedSourceMaps = {};\nvar nextStackFilenameCounter = 1;\n\n// Use the source maps specified to runJavaScript\nvar useParsedSourceMap = function (pathForSourceMap) {\n  // Check our fancy source map data structure, used for isopacks\n  if (_.has(parsedSourceMaps, pathForSourceMap)) {\n    return {map: parsedSourceMaps[pathForSourceMap]};\n  }\n\n  return null;\n};\n\n// Try this source map first\nsourceMapRetrieverStack.push(useParsedSourceMap);\n\n// Fibers are disabled by default for files.* operations unless\n// process.env.METEOR_DISABLE_FS_FIBERS parses to a falsy value.\nconst YIELD_ALLOWED = !! (\n  _.has(process.env, \"METEOR_DISABLE_FS_FIBERS\") &&\n  ! JSON.parse(process.env.METEOR_DISABLE_FS_FIBERS));\n\nfunction canYield() {\n  return Fiber.current &&\n    Fiber.yield &&\n    ! Fiber.yield.disallowed;\n}\n\nfunction mayYield() {\n  return YIELD_ALLOWED && canYield();\n}\n\n// given a predicate function and a starting path, traverse upwards\n// from the path until we find a path that satisfies the predicate.\n//\n// returns either the path to the lowest level directory that passed\n// the test or null for none found. if starting path isn't given, use\n// cwd.\nvar findUpwards = function (predicate, startPath) {\n  var testDir = startPath || files.cwd();\n  while (testDir) {\n    if (predicate(testDir)) {\n      break;\n    }\n    var newDir = files.pathDirname(testDir);\n    if (newDir === testDir) {\n      testDir = null;\n    } else {\n      testDir = newDir;\n    }\n  }\n  if (!testDir) {\n    return null;\n  }\n\n  return testDir;\n};\n\nfiles.cwd = function () {\n  return files.convertToStandardPath(process.cwd());\n};\n\n// Determine if 'filepath' (a path, or omit for cwd) is within an app\n// directory. If so, return the top-level app directory.\nfiles.findAppDir = function (filepath) {\n  var isAppDir = function (filepath) {\n    // XXX once we are done with the transition to engine, this should\n    // change to: `return files.exists(path.join(filepath, '.meteor',\n    // 'release'))`\n\n    // .meteor/packages can be a directory, if .meteor is a warehouse\n    // directory.  since installing meteor initializes a warehouse at\n    // $HOME/.meteor, we want to make sure your home directory (and all\n    // subdirectories therein) don't count as being within a meteor app.\n    try { // use try/catch to avoid the additional syscall to files.exists\n      return files.stat(\n        files.pathJoin(filepath, '.meteor', 'packages')).isFile();\n    } catch (e) {\n      return false;\n    }\n  };\n\n  return findUpwards(isAppDir, filepath);\n};\n\nfiles.findPackageDir = function (filepath) {\n  var isPackageDir = function (filepath) {\n    try {\n      return files.stat(files.pathJoin(filepath, 'package.js')).isFile();\n    } catch (e) {\n      return false;\n    }\n  };\n\n  return findUpwards(isPackageDir, filepath);\n};\n\n// create a .gitignore file in dirPath if one doesn't exist. add\n// 'entry' to the .gitignore on its own line at the bottom of the\n// file, if the exact line does not already exist in the file.\nfiles.addToGitignore = function (dirPath, entry) {\n  var filepath = files.pathJoin(dirPath, \".gitignore\");\n  if (files.exists(filepath)) {\n    var data = files.readFile(filepath, 'utf8');\n    var lines = data.split(/\\n/);\n    if (_.any(lines, function (x) { return x === entry; })) {\n      // already there do nothing\n    } else {\n      // rewrite file w/ new entry.\n      if (data.substr(-1) !== \"\\n\") {\n        data = data + \"\\n\";\n      }\n      data = data + entry + \"\\n\";\n      files.writeFile(filepath, data, 'utf8');\n    }\n  } else {\n    // doesn't exist, just write it.\n    files.writeFile(filepath, entry + \"\\n\", 'utf8');\n  }\n};\n\n// Are we running Meteor from a git checkout?\nfiles.inCheckout = _.once(function () {\n  try {\n    if (files.exists(files.pathJoin(files.getCurrentToolsDir(), '.git'))) {\n      return true;\n    }\n  } catch (e) { console.log(e); }\n\n  return false;\n});\n\n// True if we are using a warehouse: either installed Meteor, or if\n// $METEOR_WAREHOUSE_DIR is set. Otherwise false (we're in a git checkout and\n// just using packages from the checkout).\nfiles.usesWarehouse = function () {\n  // Test hook: act like we're \"installed\" using a non-homedir warehouse\n  // directory.\n  if (process.env.METEOR_WAREHOUSE_DIR) {\n    return true;\n  } else {\n    return ! files.inCheckout();\n  }\n};\n\n// Read the '.tools_version.txt' file. If in a checkout, throw an error.\nfiles.getToolsVersion = function () {\n  if (! files.inCheckout()) {\n    var isopackJsonPath = files.pathJoin(files.getCurrentToolsDir(),\n      '..',  // get out of tool, back to package\n      'isopack.json');\n\n    var parsed;\n\n    if (files.exists(isopackJsonPath)) {\n      var isopackJson = files.readFile(isopackJsonPath);\n      parsed = JSON.parse(isopackJson);\n\n      // XXX \"isopack-1\" is duplicate of isopack.currentFormat\n      parsed = parsed[\"isopack-1\"]; // get the right format from the JSON\n      return parsed.name + '@' + parsed.version;\n    }\n\n    // XXX COMPAT WITH 0.9.3\n    var unipackageJsonPath = files.pathJoin(files.getCurrentToolsDir(),\n      '..',  // get out of tool, back to package\n      'unipackage.json');\n    var unipackageJson = files.readFile(unipackageJsonPath);\n    parsed = JSON.parse(unipackageJson);\n    return parsed.name + '@' + parsed.version;\n\n  } else {\n    throw new Error(\"Unexpected. Git checkouts don't have tools versions.\");\n  }\n};\n\n// Return the root of dev_bundle (probably /usr/local/meteor in an\n// install, or (checkout root)/dev_bundle in a checkout.).\nfiles.getDevBundle = function () {\n  return files.pathJoin(files.getCurrentToolsDir(), 'dev_bundle');\n};\n\nfiles.getCurrentNodeBinDir = function () {\n  return files.pathJoin(files.getDevBundle(), \"bin\");\n}\n\n// Return the top-level directory for this meteor install or checkout\nfiles.getCurrentToolsDir = function () {\n  return files.pathDirname(\n    files.pathDirname(\n      files.convertToStandardPath(__dirname)));\n};\n\n// Read a settings file and sanity-check it. Returns a string on\n// success or null on failure (in which case buildmessages will be\n// emitted).\nfiles.getSettings = function (filename, watchSet) {\n  buildmessage.assertInCapture();\n  var absPath = files.pathResolve(filename);\n  var buffer = require(\"./watch.js\").readAndWatchFile(watchSet, absPath);\n  if (buffer === null) {\n    buildmessage.error(\"file not found (settings file)\",\n                       { file: filename });\n    return null;\n  }\n\n  if (buffer.length > 0x10000) {\n    buildmessage.error(\"settings file is too large (must be less than 64k)\",\n                       { file: filename });\n    return null;\n  }\n\n  var str = buffer.toString('utf8');\n\n  // Ensure that the string is parseable in JSON, but there's no reason to use\n  // the object value of it yet.\n  if (str.match(/\\S/)) {\n    try {\n      JSON.parse(str);\n    } catch (e) {\n      buildmessage.error(\"parse error reading settings file\",\n                         { file: filename });\n    }\n  }\n\n  return str;\n};\n\n// Try to find the prettiest way to present a path to the\n// user. Presently, the main thing it does is replace $HOME with ~.\nfiles.prettyPath = function (p) {\n  p = files.realpath(p);\n  var home = files.getHomeDir();\n  if (! home) {\n    return p;\n  }\n  var relativeToHome = files.pathRelative(home, p);\n  if (relativeToHome.substr(0, 3) === ('..' + files.pathSep)) {\n    return p;\n  }\n  return files.pathJoin('~', relativeToHome);\n};\n\n// Like statSync, but null if file not found\nfiles.statOrNull = function (path) {\n  return statOrNull(path);\n};\n\nfunction statOrNull(path, preserveSymlinks) {\n  try {\n    return preserveSymlinks\n      ? files.lstat(path)\n      : files.stat(path);\n  } catch (e) {\n    if (e.code === \"ENOENT\") {\n      return null;\n    }\n    throw e;\n  }\n}\n\nfiles.rm_recursive_async = (path) => {\n  return new Promise((resolve, reject) => {\n    rimraf(files.convertToOSPath(path), err => err\n      ? reject(err)\n      : resolve());\n  });\n};\n\n// Like rm -r.\nfiles.rm_recursive = Profile(\"files.rm_recursive\", (path) => {\n  try {\n    rimraf.sync(files.convertToOSPath(path));\n  } catch (e) {\n    if (e.code === \"ENOTEMPTY\" && canYield()) {\n      files.rm_recursive_async(path).await();\n      return;\n    }\n    throw e;\n  }\n});\n\n// Returns the base64 SHA256 of the given file.\nfiles.fileHash = function (filename) {\n  var crypto = require('crypto');\n  var hash = crypto.createHash('sha256');\n  hash.setEncoding('base64');\n  var rs = files.createReadStream(filename);\n  return new Promise(function (resolve) {\n    rs.on('end', function () {\n      rs.close();\n      resolve(hash.digest('base64'));\n    });\n    rs.pipe(hash, { end: false });\n  }).await();\n};\n\n// This is the result of running fileHash on a blank file.\nfiles.blankHash = \"47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=\";\n\n// Returns a base64 SHA256 hash representing a tree on disk. It is not sensitive\n// to modtime, uid/gid, or any permissions bits other than the current-user-exec\n// bit on normal files.\nfiles.treeHash = function (root, options) {\n  options = _.extend({\n    ignore: function (relativePath) {\n      return false;\n    }\n  }, options);\n\n  var crypto = require('crypto');\n  var hash = crypto.createHash('sha256');\n\n  var hashLog = process.env.TREE_HASH_DEBUG ?\n        ['\\n\\nTREE HASH for ' + root + '\\n'] : null;\n\n  var updateHash = function (text) {\n    hashLog && hashLog.push(text);\n    hash.update(text);\n  };\n\n  var traverse = function (relativePath) {\n    if (options.ignore(relativePath)) {\n      hashLog && hashLog.push('SKIP ' + JSON.stringify(relativePath) + '\\n');\n      return;\n    }\n\n    var absPath = files.pathJoin(root, relativePath);\n    var stat = files.lstat(absPath);\n\n    if (stat.isDirectory()) {\n      if (relativePath) {\n        updateHash('dir ' + JSON.stringify(relativePath) + '\\n');\n      }\n      _.each(files.readdir(absPath), function (entry) {\n        traverse(files.pathJoin(relativePath, entry));\n      });\n    } else if (stat.isFile()) {\n      if (!relativePath) {\n        throw Error(\"must call files.treeHash on a directory\");\n      }\n      updateHash('file ' + JSON.stringify(relativePath) + ' ' +\n                  stat.size + ' ' + files.fileHash(absPath) + '\\n');\n      if (stat.mode & 0o100) {\n        updateHash('exec\\n');\n      }\n    } else if (stat.isSymbolicLink()) {\n      if (!relativePath) {\n        throw Error(\"must call files.treeHash on a directory\");\n      }\n      updateHash('symlink ' + JSON.stringify(relativePath) + ' ' +\n                 JSON.stringify(files.readlink(absPath)) + '\\n');\n    }\n    // ignore anything weirder\n  };\n\n  traverse('');\n  hashLog && files.appendFile(process.env.TREE_HASH_DEBUG, hashLog.join(''));\n  return hash.digest('base64');\n};\n\n// like mkdir -p. if it returns true, the item is a directory (even if\n// it was already created). if it returns false, the item is not a\n// directory and we couldn't make it one.\nfiles.mkdir_p = function (dir, mode) {\n  var p = files.pathResolve(dir);\n  var ps = files.pathNormalize(p).split(files.pathSep);\n\n  var stat = files.statOrNull(p);\n  if (stat) {\n    return stat.isDirectory();\n  }\n\n  // doesn't exist. recurse to build parent.\n  // Don't use files.pathJoin here because it can strip off the leading slash\n  // accidentally.\n  var parentPath = ps.slice(0, -1).join(files.pathSep);\n  var success = files.mkdir_p(parentPath, mode);\n  // parent is not a directory.\n  if (! success) { return false; }\n\n  var pathIsDirectory = function (path) {\n    var stat = files.statOrNull(path);\n    return stat && stat.isDirectory();\n  };\n\n  try {\n    files.mkdir(p, mode);\n  } catch (err) {\n    if (err.code === \"EEXIST\") {\n      if (pathIsDirectory(p)) {\n        // all good, someone else created this directory for us while we were\n        // yielding\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      throw err;\n    }\n  }\n\n  // double check we exist now\n  return pathIsDirectory(p);\n};\n\n// Roughly like cp -R.\n//\n// The output files will be readable and writable by everyone that the umask\n// allows, and executable by everyone (modulo umask) if the original file was\n// owner-executable. Symlinks are treated transparently (ie the contents behind\n// them are copied, and it's an error if that points nowhere).\n//\n// If options.transform{Filename, Contents} is present, it should\n// be a function, and the contents (as a buffer) or filename will be\n// passed through the function. Use this to, eg, fill templates.\n//\n// If options.ignore is present, it should be a list of regexps. Any\n// file whose basename matches one of the regexps, before\n// transformation, will be skipped.\nfiles.cp_r = function(from, to, options = {}) {\n  from = files.pathResolve(from);\n\n  const stat = statOrNull(from, options.preserveSymlinks);\n  if (! stat) {\n    return;\n  }\n\n  if (stat.isDirectory()) {\n    files.mkdir_p(to, 0o755);\n\n    files.readdir(from).forEach(f => {\n      if (options.ignore &&\n          _.any(options.ignore,\n                pattern => f.match(pattern))) {\n        return;\n      }\n\n      const fullFrom = files.pathJoin(from, f);\n\n      if (options.transformFilename) {\n        f = options.transformFilename(f);\n      }\n\n      files.cp_r(\n        fullFrom,\n        files.pathJoin(to, f),\n        options\n      );\n    })\n\n    return;\n  }\n\n  files.mkdir_p(files.pathDirname(to));\n\n  if (stat.isSymbolicLink()) {\n    files.symlink(files.readlink(from), to);\n\n  } else {\n    // Create the file as readable and writable by everyone, and\n    // executable by everyone if the original file is executable by\n    // owner. (This mode will be modified by umask.) We don't copy the\n    // mode *directly* because this function is used by 'meteor create'\n    // which is copying from the read-only tools tree into a writable app.\n    const mode = (stat.mode & 0o100) ? 0o777 : 0o666;\n\n    if (options.transformContents) {\n      files.writeFile(to, options.transformContents(\n        files.readFile(from),\n        files.pathBasename(from)\n      ), { mode });\n\n    } else {\n      copyFileHelper(from, to, mode);\n    }\n  }\n};\n\n/**\n * Get every path in a directory recursively, treating symlinks as files\n * @param  {String} dir     The directory to walk, either relative to options.cwd or completely absolute\n * @param  {Object} options Some options\n * @param {String} options.cwd The directory that paths should be relative to\n * @param {String[]} options.output An array to push results to\n * @return {String[]}         All of the paths in the directory recursively\n */\nfiles.getPathsInDir = function (dir, options) {\n  // Don't let this function yield so that the file system doesn't get changed\n  // underneath us\n  return fiberHelpers.noYieldsAllowed(function () {\n    var cwd = options.cwd || files.convertToStandardPath(process.cwd());\n\n    if (! files.exists(cwd)) {\n      throw new Error(\"Specified current working directory doesn't exist: \" +\n        cwd);\n    }\n\n    var absoluteDir = files.pathResolve(cwd, dir);\n\n    if (! files.exists(absoluteDir)) {\n      // There are no paths in this dir, so don't do anything\n      return;\n    }\n\n    var output = options.output || [];\n\n    var pathIsDirectory = function (path) {\n      var stat = files.lstat(path);\n      return stat.isDirectory();\n    };\n\n    _.each(files.readdir(absoluteDir), function (entry) {\n      var newPath = files.pathJoin(dir, entry);\n      var newAbsPath = files.pathJoin(absoluteDir, entry);\n\n      output.push(newPath);\n\n      if (pathIsDirectory(newAbsPath)) {\n        files.getPathsInDir(newPath, {\n          cwd: cwd,\n          output: output\n        });\n      }\n    });\n\n    return output;\n  });\n};\n\nfiles.findPathsWithRegex = function (dir, regex, options) {\n  var allPaths = files.getPathsInDir(dir, {\n    cwd: options.cwd\n  });\n\n  return _.filter(allPaths, function (path) {\n    return path.match(regex);\n  });\n};\n\n// Copies a file, which is expected to exist. Parent directories of \"to\" do not\n// have to exist. Treats symbolic links transparently (copies the contents, not\n// the link itself, and it's an error if the link doesn't point to a file).\nfiles.copyFile = function (from, to, origMode=null) {\n  files.mkdir_p(files.pathDirname(files.pathResolve(to)), 0o755);\n\n  if (origMode === null) {\n    var stats = files.stat(from);\n    if (!stats.isFile()) {\n      throw Error(\"cannot copy non-files\");\n    }\n    origMode = stats.mode;\n  }\n\n  // Create the file as readable and writable by everyone, and executable by\n  // everyone if the original file is executably by owner. (This mode will be\n  // modified by umask.) We don't copy the mode *directly* because this function\n  // is used by 'meteor create' which is copying from the read-only tools tree\n  // into a writable app.\n  var mode = (origMode & 0o100) ? 0o777 : 0o666;\n\n  copyFileHelper(from, to, mode);\n};\nfiles.copyFile = Profile(\"files.copyFile\", files.copyFile);\n\nvar copyFileHelper = function (from, to, mode) {\n  var readStream = files.createReadStream(from);\n  var writeStream = files.createWriteStream(to, { mode: mode });\n  new Promise(function (resolve, reject) {\n    readStream.on('error', reject);\n    writeStream.on('error', reject);\n    writeStream.on('open', function () {\n      readStream.pipe(writeStream);\n    });\n    writeStream.once('finish', resolve);\n  }).await();\n};\n\n// Make a temporary directory. Returns the path to the newly created\n// directory. Only the current user is allowed to read or write the\n// files in the directory (or add files to it). The directory will\n// be cleaned up on exit.\nconst tempDirs = Object.create(null);\nfiles.mkdtemp = function (prefix) {\n  var make = function () {\n    prefix = prefix || 'mt-';\n    // find /tmp\n    var tmpDir = _.first(_.map(['TMPDIR', 'TMP', 'TEMP'], function (t) {\n      return process.env[t];\n    }).filter(_.identity));\n\n    if (! tmpDir && process.platform !== 'win32') {\n      tmpDir = '/tmp';\n    }\n\n    if (! tmpDir) {\n      throw new Error(\"Couldn't create a temporary directory.\");\n    }\n\n    tmpDir = files.realpath(tmpDir);\n\n    // make the directory. give it 3 tries in case of collisions from\n    // crappy random.\n    var tries = 3;\n    while (tries > 0) {\n      var dirPath = files.pathJoin(\n        tmpDir, prefix + (Math.random() * 0x100000000 + 1).toString(36));\n      try {\n        files.mkdir(dirPath, 0o700);\n        return dirPath;\n      } catch (err) {\n        tries--;\n      }\n    }\n    throw new Error(\"failed to make temporary directory in \" + tmpDir);\n  };\n  var dir = make();\n  tempDirs[dir] = true;\n  return dir;\n};\n\n// Call this if you're done using a temporary directory. It will asynchronously\n// be deleted.\nfiles.freeTempDir = function (dir) {\n  if (! tempDirs[dir]) {\n    throw Error(\"not a tracked temp dir: \" + dir);\n  }\n\n  if (process.env.METEOR_SAVE_TMPDIRS) {\n    return;\n  }\n\n  return files.rm_recursive_async(dir).then(() => {\n    // Delete tempDirs[dir] only when the removal finishes, so that the\n    // cleanup.onExit handler can attempt the removal synchronously if it\n    // fires in the meantime.\n    delete tempDirs[dir];\n  }, error => {\n    // Leave tempDirs[dir] in place so the cleanup.onExit handler can try\n    // to delete it again when the process exits.\n    console.log(error);\n  });\n};\n\nif (! process.env.METEOR_SAVE_TMPDIRS) {\n  cleanup.onExit(function (sig) {\n    Object.keys(tempDirs).forEach(dir => {\n      delete tempDirs[dir];\n      try {\n        files.rm_recursive(dir);\n      } catch (err) {\n        // Don't crash and print a stack trace because we failed to delete\n        // a temp directory. This happens sometimes on Windows and seems\n        // to be unavoidable.\n      }\n    });\n  });\n}\n\n// Takes a buffer containing `.tar.gz` data and extracts the archive\n// into a destination directory. destPath should not exist yet, and\n// the archive should contain a single top-level directory, which will\n// be renamed atomically to destPath.\nfiles.extractTarGz = function (buffer, destPath, options) {\n  var options = options || {};\n  var parentDir = files.pathDirname(destPath);\n  var tempDir = files.pathJoin(parentDir, '.tmp' + utils.randomToken());\n  files.mkdir_p(tempDir);\n\n  if (! _.has(options, \"verbose\")) {\n    options.verbose = require(\"../console/console.js\").Console.verbose;\n  }\n\n  const startTime = +new Date;\n\n  let promise = process.platform === \"win32\"\n    ? tryExtractWithNative7z(buffer, tempDir, options)\n    : tryExtractWithNativeTar(buffer, tempDir, options)\n\n  promise = promise.catch(\n    error => tryExtractWithNpmTar(buffer, tempDir, options)\n  );\n\n  promise.await();\n\n  // succeed!\n  var topLevelOfArchive = files.readdir(tempDir)\n    // On Windows, the 7z.exe tool sometimes creates an auxiliary\n    // PaxHeader directory.\n    .filter(file => ! file.startsWith(\"PaxHeader\"));\n\n  if (topLevelOfArchive.length !== 1) {\n    throw new Error(\n      \"Extracted archive '\" + tempDir + \"' should only contain one entry\");\n  }\n\n  var extractDir = files.pathJoin(tempDir, topLevelOfArchive[0]);\n  files.rename(extractDir, destPath);\n  files.rm_recursive(tempDir);\n\n  if (options.verbose) {\n    console.log(\"Finished extracting in\", new Date - startTime, \"ms\");\n  }\n};\n\nfunction ensureDirectoryEmpty(dir) {\n  files.readdir(dir).forEach(file => {\n    files.rm_recursive(files.pathJoin(dir, file));\n  });\n}\n\nfunction tryExtractWithNativeTar(buffer, tempDir, options) {\n  ensureDirectoryEmpty(tempDir);\n\n  if (options.forceConvert) {\n    return Promise.reject(new Error(\n      \"Native tar cannot convert colons in package names\"));\n  }\n\n  return new Promise((resolve, reject) => {\n    const flags = options.verbose ? \"-xzvf\" : \"-xzf\";\n    const tarProc = spawn(\"tar\", [flags, \"-\"], {\n      cwd: files.convertToOSPath(tempDir),\n      stdio: options.verbose ? [\n        \"pipe\", // Always need to write to tarProc.stdin.\n        process.stdout,\n        process.stderr\n      ] : \"pipe\",\n    });\n\n    tarProc.on(\"error\", reject);\n    tarProc.on(\"exit\", resolve);\n\n    tarProc.stdin.write(buffer);\n    tarProc.stdin.end();\n  });\n}\n\nfunction tryExtractWithNative7z(buffer, tempDir, options) {\n  ensureDirectoryEmpty(tempDir);\n\n  if (options.forceConvert) {\n    return Promise.reject(new Error(\n      \"Native 7z.exe cannot convert colons in package names\"));\n  }\n\n  const exeOSPath = files.convertToOSPath(\n    files.pathJoin(files.getCurrentNodeBinDir(), \"7z.exe\"));\n  const tarGzBasename = \"out.tar.gz\";\n  const spawnOptions = {\n    cwd: files.convertToOSPath(tempDir),\n    stdio: options.verbose ? \"inherit\" : \"pipe\",\n  };\n\n  files.writeFile(files.pathJoin(tempDir, tarGzBasename), buffer);\n\n  return new Promise((resolve, reject) => {\n    spawn(exeOSPath, [\n      \"x\", \"-y\", tarGzBasename\n    ], spawnOptions)\n      .on(\"error\", reject)\n      .on(\"exit\", resolve);\n\n  }).then(code => {\n    assert.strictEqual(code, 0);\n\n    let tarBasename;\n    const foundTar = files.readdir(tempDir).some(file => {\n      if (file !== tarGzBasename) {\n        tarBasename = file;\n        return true;\n      }\n    });\n\n    assert.ok(foundTar, \"failed to find .tar file\");\n\n    function cleanUp() {\n      files.unlink(files.pathJoin(tempDir, tarGzBasename));\n      files.unlink(files.pathJoin(tempDir, tarBasename));\n    }\n\n    return new Promise((resolve, reject) => {\n      spawn(exeOSPath, [\n        \"x\", \"-y\", tarBasename\n      ], spawnOptions)\n        .on(\"error\", reject)\n        .on(\"exit\", resolve);\n\n    }).then(code => {\n      cleanUp();\n      return code;\n    }, error => {\n      cleanUp();\n      throw error;\n    });\n  });\n}\n\nfunction tryExtractWithNpmTar(buffer, tempDir, options) {\n  ensureDirectoryEmpty(tempDir);\n\n  var tar = require(\"tar\");\n  var zlib = require(\"zlib\");\n\n  return new Promise((resolve, reject) => {\n    var gunzip = zlib.createGunzip().on('error', reject);\n    var extractor = new tar.Extract({\n      path: files.convertToOSPath(tempDir)\n    }).on('entry', function (e) {\n      if (process.platform === \"win32\" || options.forceConvert) {\n        // On Windows, try to convert old packages that have colons in\n        // paths by blindly replacing all of the paths. Otherwise, we\n        // can't even extract the tarball\n        e.path = colonConverter.convert(e.path);\n      }\n    }).on('error', reject)\n      .on('end', resolve);\n\n    // write the buffer to the (gunzip|untar) pipeline; these calls\n    // cause the tar to be extracted to disk.\n    gunzip.pipe(extractor);\n    gunzip.write(buffer);\n    gunzip.end();\n  });\n}\n\n// In the same fashion as node-pre-gyp does, add the executable\n// bit but only if the read bit was present.  Same as:\n// https://github.com/mapbox/node-pre-gyp/blob/7a28f4b0f562ba4712722fefe4eeffb7b20fbf7a/lib/install.js#L71-L77\n// and others reported in: https://github.com/npm/node-tar/issues/7\nfunction addExecBitWhenReadBitPresent(fileMode) {\n  return fileMode |= (fileMode >>> 2) & 0o111;\n}\n\n// Tar-gzips a directory, returning a stream that can then be piped as\n// needed.  The tar archive will contain a top-level directory named\n// after dirPath.\nfiles.createTarGzStream = function (dirPath, options) {\n  var tar = require(\"tar\");\n  var fstream = require('fstream');\n  var zlib = require(\"zlib\");\n\n  // Create a segment of the file path which we will look for to\n  // identify exactly what we think is a \"bin\" file (that is, something\n  // which should be expected to work within the context of an\n  // 'npm run-script').\n  var binPathMatch = [\"\", \"node_modules\", \".bin\", \"\"].join(path.sep);\n\n  // Don't use `{ path: dirPath, type: 'Directory' }` as an argument to\n  // fstream.Reader. This triggers a collection of odd behaviors in fstream\n  // (which might be bugs or might just be weirdnesses).\n  //\n  // First, if we pass an object with `type: 'Directory'` as an argument, then\n  // the resulting tarball has no entry for the top-level directory, because\n  // the reader emits an entry (with just the path, no permissions or other\n  // properties) before the pipe to gzip is even set up, so that entry gets\n  // lost. Even if we pause the streams until all the pipes are set up, we'll\n  // get the entry in the tarball for the top-level directory without\n  // permissions or other properties, which is problematic. Just passing\n  // `dirPath` appears to cause `fstream` to stat the directory before emitting\n  // an entry for it, so the pipes are set up by the time the entry is emitted,\n  // and the entry has all the right permissions, etc. from statting it.\n  //\n  // The second weird behavior is that we need an entry for the top-level\n  // directory in the tarball to untar it with npm `tar`. (GNU tar, in\n  // contrast, appears to have no problems untarring tarballs without entries\n  // for the top-level directory inside them.) The problem is that, without an\n  // entry for the top-level directory, `fstream` will create the directory\n  // with the same permissions as the first file inside it. This manifests as\n  // an EACCESS when untarring if the first file inside the top-level directory\n  // is not writeable.\n  var fileStream = fstream.Reader({\n    path: files.convertToOSPath(dirPath),\n    filter: function (entry) {\n      if (process.platform !== \"win32\") {\n        return true;\n      }\n\n      // Refuse to create a directory that isn't listable. Tarballs\n      // created on Windows will have non-executable directories (since\n      // executable isn't a thing in Windows directory permissions), and\n      // so the resulting extracted directories will not be listable on\n      // Linux/Mac unless we explicitly make them executable. We think\n      // this should really be an option that you pass to node tar, but\n      // setting it in an 'entry' handler is the same strategy that npm\n      // does, so we do that here too.\n      if (entry.type === \"Directory\") {\n        entry.props.mode = addExecBitWhenReadBitPresent(entry.props.mode);\n      }\n\n      // In a similar way as for directories, but only if is in a path\n      // location that is expected to be executable (npm \"bin\" links)\n      if (entry.type === \"File\" && entry.path.indexOf(binPathMatch) > -1) {\n        entry.props.mode = addExecBitWhenReadBitPresent(entry.props.mode);\n      }\n\n      return true;\n    }\n  });\n  var tarStream = fileStream.pipe(tar.Pack({ noProprietary: true }));\n\n  return tarStream.pipe(zlib.createGzip());\n};\n\n// Tar-gzips a directory into a tarball on disk, synchronously.\n// The tar archive will contain a top-level directory named after dirPath.\nfiles.createTarball = function (dirPath, tarball, options) {\n  var out = files.createWriteStream(tarball);\n  new Promise(function (resolve, reject) {\n    out.on('error', reject);\n    out.on('close', resolve);\n    files.createTarGzStream(dirPath, options).pipe(out);\n  }).await();\n};\n\n// Use this if you'd like to replace a directory with another\n// directory as close to atomically as possible. It's better than\n// recursively deleting the target directory first and then\n// renaming. (Failure modes here include \"there's a brief moment where\n// toDir does not exist\" and \"you can end up with garbage directories\n// sitting around\", but not \"there's any time where toDir exists but\n// is in a state other than initial or final\".)\nfiles.renameDirAlmostAtomically =\n  Profile(\"files.renameDirAlmostAtomically\", (fromDir, toDir) => {\n    const garbageDir = `${toDir}-garbage-${utils.randomToken()}`;\n\n    // Get old dir out of the way, if it exists.\n    let cleanupGarbage = false;\n    let forceCopy = false;\n    try {\n      files.rename(toDir, garbageDir);\n      cleanupGarbage = true;\n    } catch (e) {\n      if (e.code === 'EXDEV') {\n        // Some (notably Docker) file systems will fail to do a seemingly\n        // harmless operation, such as renaming, on what is apparently the same\n        // file system.  AUFS will do this even if the `fromDir` and `toDir`\n        // are on the same layer, and OverlayFS will fail if the `fromDir` and\n        // `toDir` are on different layers.  In these cases, we will not be\n        // atomic and will need to do a recursive copy.\n        forceCopy = true;\n      } else if (e.code !== 'ENOENT') {\n        // No such file or directory is okay, but anything else is not.\n        throw e;\n      }\n    }\n\n    if (! forceCopy) {\n      try {\n        files.rename(fromDir, toDir);\n      } catch (e) {\n        // It's possible that there may not have been a `toDir` to have\n        // advanced warning about this, so we're prepared to handle it again.\n        if (e.code === 'EXDEV') {\n          forceCopy = true;\n        } else {\n          throw e;\n        }\n      }\n    }\n\n    // If we've been forced to jeopardize our atomicity due to file-system\n    // limitations, we'll resort to copying.\n    if (forceCopy) {\n      files.rm_recursive(toDir);\n      files.cp_r(fromDir, toDir);\n    }\n\n    // ... and take out the trash.\n    if (cleanupGarbage) {\n      // We don't care about how long this takes, so we'll let it go async.\n      files.rm_recursive(garbageDir);\n    }\n  });\n\nfiles.writeFileAtomically =\n  Profile(\"files.writeFileAtomically\", function (filename, contents) {\n    const parentDir = files.pathDirname(filename);\n    files.mkdir_p(parentDir);\n\n    const tmpFile = files.pathJoin(\n      parentDir,\n      '.' + files.pathBasename(filename) + '.' + utils.randomToken()\n    );\n\n    files.writeFile(tmpFile, contents);\n    files.rename(tmpFile, filename);\n  });\n\n// Like fs.symlinkSync, but creates a temporay link and renames it over the\n// file; this means it works even if the file already exists.\n// Do not use this function on Windows, it won't work.\nfiles.symlinkOverSync = function (linkText, file) {\n  fiberHelpers.noYieldsAllowed(function () {\n    file = files.pathResolve(file);\n    var tmpSymlink = files.pathJoin(\n      files.pathDirname(file),\n      \".\" + files.pathBasename(file) + \".tmp\" + utils.randomToken());\n    files.symlink(linkText, tmpSymlink);\n    files.rename(tmpSymlink, file);\n  });\n};\n\n// Return the result of evaluating `code` using\n// `runInThisContext`. `code` will be wrapped in a closure. You can\n// pass additional values to bind in the closure in `options.symbols`,\n// the keys being the symbols to bind and the values being their\n// values. `options.filename` is the filename to use in exceptions\n// that come from inside this code. `options.sourceMap` is an optional\n// source map that represents the file.\n//\n// The really special thing about this function is that if a parse\n// error occurs, we will raise an exception of type\n// files.FancySyntaxError, from which you may read 'message', 'file',\n// 'line', and 'column' attributes ... v8 is normally reluctant to\n// reveal this information but will write it to stderr if you pass it\n// an undocumented flag. Unforunately though node doesn't have dup2 so\n// we can't intercept the write. So instead we use a completely\n// different parser with a better error handling API. Ah well.  The\n// underlying V8 issue is:\n//   https://code.google.com/p/v8/issues/detail?id=1281\nfiles.runJavaScript = function (code, options) {\n  if (typeof code !== 'string') {\n    throw new Error(\"code must be a string\");\n  }\n\n  options = options || {};\n  var filename = options.filename || \"<anonymous>\";\n\n  return Profile.time('runJavaScript ' + filename, () => {\n\n    var keys = [], values = [];\n    // don't assume that _.keys and _.values are guaranteed to\n    // enumerate in the same order\n    _.each(options.symbols, function (value, name) {\n      keys.push(name);\n      values.push(value);\n    });\n\n    var stackFilename = filename;\n    if (options.sourceMap) {\n      // We want to generate an arbitrary filename that we use to associate the\n      // file with its source map.\n      stackFilename = \"<runJavaScript-\" + nextStackFilenameCounter++ + \">\";\n    }\n\n    var chunks = [];\n    var header = \"(function(\" + keys.join(',') + \"){\";\n    chunks.push(header);\n    if (options.sourceMap) {\n      var consumer = new sourcemap.SourceMapConsumer(options.sourceMap);\n      chunks.push(sourcemap.SourceNode.fromStringWithSourceMap(\n        code, consumer));\n    } else {\n      chunks.push(code);\n    }\n    // \\n is necessary in case final line is a //-comment\n    chunks.push(\"\\n})\");\n\n    var wrapped;\n    var parsedSourceMap = null;\n    if (options.sourceMap) {\n      var node = new sourcemap.SourceNode(null, null, null, chunks);\n      var results = node.toStringWithSourceMap({\n        file: stackFilename\n      });\n      wrapped = results.code;\n      parsedSourceMap = results.map.toJSON();\n      if (options.sourceMapRoot) {\n        // Add the specified root to any root that may be in the file.\n        parsedSourceMap.sourceRoot = files.pathJoin(\n          options.sourceMapRoot, parsedSourceMap.sourceRoot || '');\n      }\n      // source-map-support doesn't ever look at the sourcesContent field, so\n      // there's no point in keeping it in memory.\n      delete parsedSourceMap.sourcesContent;\n      parsedSourceMaps[stackFilename] = parsedSourceMap;\n    } else {\n      wrapped = chunks.join('');\n    };\n\n    try {\n      // See #runInThisContext\n      //\n      // XXX it'd be nice to runInNewContext so that the code can't mess\n      // with our globals, but objects that come out of runInNewContext\n      // have bizarro antimatter prototype chains and break 'instanceof\n      // Array'. for now, steer clear\n      //\n      // Pass 'true' as third argument if we want the parse error on\n      // stderr (which we don't).\n      var script = require('vm').createScript(wrapped, stackFilename);\n    } catch (nodeParseError) {\n      if (!(nodeParseError instanceof SyntaxError)) {\n        throw nodeParseError;\n      }\n      // Got a parse error. Unfortunately, we can't actually get the\n      // location of the parse error from the SyntaxError; Node has some\n      // hacky support for displaying it over stderr if you pass an\n      // undocumented third argument to stackFilename, but that's not\n      // what we want. See\n      //    https://github.com/joyent/node/issues/3452\n      // for more information. One thing to try (and in fact, what an\n      // early version of this function did) is to actually fork a new\n      // node to run the code and parse its output. We instead run an\n      // entirely different JS parser, from the Babel project, but\n      // which at least has a nice API for reporting errors.\n      var parse = require('meteor-babel').parse;\n      try {\n        parse(wrapped, { strictMode: false });\n      } catch (parseError) {\n        if (typeof parseError.loc !== \"object\") {\n          throw parseError;\n        }\n\n        var err = new files.FancySyntaxError;\n        err.message = parseError.message;\n\n        if (parsedSourceMap) {\n          // XXX this duplicates code in computeGlobalReferences\n          var consumer2 = new sourcemap.SourceMapConsumer(parsedSourceMap);\n          var original = consumer2.originalPositionFor(parseError.loc);\n          if (original.source) {\n            err.file = original.source;\n            err.line = original.line;\n            err.column = original.column;\n            throw err;\n          }\n        }\n\n        err.file = filename;  // *not* stackFilename\n        err.line = parseError.loc.line;\n        err.column = parseError.loc.column;\n\n        // adjust errors on line 1 to account for our header\n        if (err.line === 1) {\n          err.column -= header.length;\n        }\n\n        throw err;\n      }\n\n      // What? Node thought that this was a parse error and Babel didn't?\n      // Eh, just throw Node's error and don't care too much about the line\n      // numbers being right.\n      throw nodeParseError;\n    }\n\n    var func = script.runInThisContext();\n\n    return (buildmessage.markBoundary(func)).apply(null, values);\n  });\n};\n\n// - message: an error message from the parser\n// - file: filename\n// - line: 1-based\n// - column: 1-based\nfiles.FancySyntaxError = function () {};\n\nfiles.OfflineError = function (error) {\n  this.error = error;\n};\nfiles.OfflineError.prototype.toString = function () {\n  return \"[Offline: \" + this.error.toString() + \"]\";\n};\n\n// Like files.readdir, but skips entries whose names begin with dots, and\n// converts ENOENT to [].\nfiles.readdirNoDots = function (path) {\n  try {\n    var entries = files.readdir(path);\n  } catch (e) {\n    if (e.code === 'ENOENT') {\n      return [];\n    }\n    throw e;\n  }\n  return _.filter(entries, function (entry) {\n    return entry && entry[0] !== '.';\n  });\n};\n\n// Read a file in line by line. Returns an array of lines to be\n// processed individually. Throws if the file doesn't exist or if\n// anything else goes wrong.\nvar getLines = function (file) {\n  var buffer = files.readFile(file);\n  var lines = exports.splitBufferToLines(buffer);\n\n  // strip blank lines at the end\n  while (lines.length) {\n    var line = lines[lines.length - 1];\n    if (line.match(/\\S/)) {\n      break;\n    }\n    lines.pop();\n  }\n\n  return lines;\n};\n\nexports.getLines = getLines;\n\nexports.splitBufferToLines = function (buffer) {\n  return buffer.toString('utf8').split(/\\r*\\n\\r*/);\n};\n\n// Same as `getLines`, but returns [] if the file doesn't exist.\nexports.getLinesOrEmpty = function (file) {\n  try {\n    return getLines(file);\n  } catch (e) {\n    if (e && e.code === 'ENOENT') {\n      return [];\n    }\n    throw e;\n  }\n};\n\n// Returns null if the file does not exist, otherwise returns the parsed JSON in\n// the file. Throws on errors other than ENOENT (including JSON parse failure).\nexports.readJSONOrNull = function (file) {\n  try {\n    var raw = files.readFile(file, 'utf8');\n  } catch (e) {\n    if (e && e.code === 'ENOENT') {\n      return null;\n    }\n    throw e;\n  }\n  return JSON.parse(raw);\n};\n\n// Trims whitespace & other filler characters of a line in a project file.\nfiles.trimSpaceAndComments = function (line) {\n  var match = line.match(/^([^#]*)#/);\n  if (match) {\n    line = match[1];\n  }\n  return files.trimSpace(line);\n};\n\n// Trims leading and trailing whilespace in a project file.\nfiles.trimSpace = function (line) {\n  return line.replace(/^\\s+|\\s+$/g, '');\n};\n\n\nfiles.KeyValueFile = function (path) {\n  var self = this;\n  self.path = path;\n}\n\n_.extend(files.KeyValueFile.prototype, {\n  set: function (k, v) {\n    var self = this;\n\n    var data = self._readAll() || '';\n    var lines = data.split(/\\n/);\n\n    var found = false;\n    for (var i = 0; i < lines.length; i++) {\n      var trimmed = lines[i].trim();\n      if (trimmed.indexOf(k + '=') == 0) {\n        lines[i] = k + '=' + v;\n        found = true;\n      }\n    }\n    if (!found) {\n      lines.push(k + \"=\" + v);\n    }\n    var newdata = lines.join('\\n') + '\\n';\n    files.writeFile(self.path, newdata, 'utf8');\n  },\n\n  _readAll: function () {\n    var self = this;\n\n    if (files.exists(self.path)) {\n      return files.readFile(self.path, 'utf8');\n    } else {\n      return null;\n    }\n  }\n});\n\nfiles.getHomeDir = function () {\n  if (process.platform === \"win32\") {\n    return files.pathDirname(\n      files.convertToStandardPath(process.env.METEOR_INSTALLATION));\n  } else {\n    return process.env.HOME;\n  }\n};\n\nfiles.currentEnvWithPathsAdded = function (...paths) {\n  const env = {...process.env};\n\n  let pathPropertyName;\n  if (process.platform === \"win32\") {\n    // process.env allows for case insensitive access on Windows, but copying it\n    // creates a normal JavaScript object with case sensitive property access.\n    // This leads to problems, because we would be adding a PATH property instead\n    // of setting Path for instance.\n    // We want to make sure we're setting the right property, so we\n    // lookup the property name case insensitively ourselves.\n    pathPropertyName = _.find(Object.keys(env), (key) => {\n      return key.toUpperCase() === 'PATH';\n    });\n    if (!pathPropertyName) {\n      pathPropertyName = 'Path';\n    }\n  } else {\n    pathPropertyName = 'PATH';\n  }\n\n  const convertedPaths = paths.map(path => files.convertToOSPath(path));\n  let pathDecomposed = (env[pathPropertyName] || \"\").split(files.pathOsDelimiter);\n  pathDecomposed.unshift(...convertedPaths);\n\n  env[pathPropertyName] = pathDecomposed.join(files.pathOsDelimiter);\n  return env;\n}\n\n// add .bat extension to link file if not present\nvar ensureBatExtension = function (p) {\n  if (p.indexOf(\".bat\") !== p.length - 4) {\n    p = p + \".bat\";\n  }\n  return p;\n};\n\n// Windows-only, generates a bat script that calls the destination bat script\nfiles._generateScriptLinkToMeteorScript = function (scriptLocation) {\n  var scriptLocationIsAbsolutePath = scriptLocation.match(/^\\//);\n  var scriptLocationConverted = scriptLocationIsAbsolutePath\n    ? files.convertToWindowsPath(scriptLocation)\n    : \"%~dp0\\\\\" + files.convertToWindowsPath(scriptLocation);\n\n  var newScript = [\n    \"@echo off\",\n    \"SETLOCAL\",\n    \"SET METEOR_INSTALLATION=%~dp0%\",\n\n    // always convert to Windows path since this function can also be\n    // called on Linux or Mac when we are building bootstrap tarballs\n    \"\\\"\" + scriptLocationConverted + \"\\\" %*\",\n    \"ENDLOCAL\",\n\n    // always exit with the same exit code as the child script\n    \"EXIT /b %ERRORLEVEL%\",\n\n    // add a comment with the destination of the link, so it can be read later\n    // by files.readLinkToMeteorScript\n    \"rem \" + scriptLocationConverted,\n  ].join(os.EOL);\n\n  return newScript;\n};\n\nfiles._getLocationFromScriptLinkToMeteorScript = function (script) {\n  var lines = _.compact(script.toString().split('\\n'));\n\n  var scriptLocation = _.last(lines)\n    .replace(/^rem /g, '');\n  var isAbsolute = true;\n\n  if (scriptLocation.match(/^%~dp0/)) {\n    isAbsolute = false;\n    scriptLocation = scriptLocation.replace(/^%~dp0\\\\?/g, '');\n  }\n\n  if (! scriptLocation) {\n    throw new Error('Failed to parse script location from meteor.bat');\n  }\n\n  return files.convertToPosixPath(scriptLocation, ! isAbsolute);\n};\n\nfiles.linkToMeteorScript = function (scriptLocation, linkLocation, platform) {\n  platform = platform || process.platform;\n\n  if (platform === 'win32') {\n    // Make a meteor batch script that points to current tool\n\n    linkLocation = ensureBatExtension(linkLocation);\n    scriptLocation = ensureBatExtension(scriptLocation);\n    var script = files._generateScriptLinkToMeteorScript(scriptLocation);\n\n    files.writeFile(linkLocation, script, {encoding: \"ascii\"});\n  } else {\n    // Symlink meteor tool\n    files.symlinkOverSync(scriptLocation, linkLocation);\n  }\n};\n\nfiles.readLinkToMeteorScript = function (linkLocation, platform) {\n  platform = platform || process.platform;\n  if (platform === 'win32') {\n    linkLocation = ensureBatExtension(linkLocation);\n    var script = files.readFile(linkLocation);\n    return files._getLocationFromScriptLinkToMeteorScript(script);\n  } else {\n    return files.readlink(linkLocation);\n  }\n};\n\n// Summary of cross platform file system handling strategy\n\n// There are three main pain points for handling files on Windows: slashes in\n// paths, line endings in text files, and colons/invalid characters in paths.\n\n// 1. Slashes in file paths\n\n//   We have decided to store all paths inside the tool as unix-style paths in\n//   the style of CYGWIN. This means that all paths have forward slashes on all\n//   platforms, and C:\\ is converted to /c/ on Windows.\n\n//   All of the methods in files.js know how to convert from these unixy paths\n//   to whatever type of path the underlying system prefers.\n\n//   The reason we chose this strategy because it was easier to make sure to use\n//   files.js everywhere instead of node's fs than to make sure every part of\n//   the tool correctly uses system-specific path separators. In addition, there\n//   are some parts of the tool where it is very hard to tell which strings are\n//   used as URLs and which are used as file paths. In some cases, a string can\n//   be used as both, meaning it has to have forward slashes no matter what.\n\n// 2. Line endings in text files\n\n//   We have decided to convert all files read by the tool to Unix-style line\n//   endings for the same reasons as slashes above. In many parts of the tool,\n//   we assume that '\\n' is the line separator, and it can be hard to find all\n//   of the places and decide whether it is appropriate to use os.EOL. We do not\n//   convert anything on write. We will wait and see if anyone complains.\n\n// 3. Colons and other invalid characters in file paths\n\n//   This is not handled automatically by files.js. You need to be careful to\n//   escape any colons in package names, etc, before using a string as a file\n//   path.\n\n//   A helpful file to import for this purpose is colon-converter.js, which also\n//   knows how to convert various configuration file formats.\n\nfiles.fsFixPath = {};\n/**\n * Wrap a function from node's fs module to use the right slashes for this OS\n * and run in a fiber, then assign it to the \"files\" namespace. Each call\n * creates a files.func that runs asynchronously with Fibers (yielding and\n * until the call is done), unless run outside a Fiber or in noYieldsAllowed, in\n * which case it uses fs.funcSync.\n *\n * Also creates a simpler version on files.fsFixPath.* that just fixes the path\n * and fiberizes the Sync version if possible.\n *\n * @param  {String} fsFuncName         The name of the node fs function to wrap\n * @param  {Number[]} pathArgIndices Indices of arguments that have paths, these\n * arguments will be converted to the correct OS slashes\n * @param  {Object} options        Some options for lesser-used cases\n * @param {Boolean} options.noErr If true, the callback of the wrapped function\n * doesn't have a first \"error\" argument, for example in fs.exists.\n * @param {Function} options.modifyReturnValue Pass in a function to modify the\n * return value\n */\nfunction wrapFsFunc(fsFuncName, pathArgIndices, options) {\n  options = options || {};\n\n  const fsFunc = fs[fsFuncName];\n  const fsFuncSync = fs[fsFuncName + \"Sync\"];\n\n  function makeWrapper ({alwaysSync, sync}) {\n    function wrapper(...args) {\n      for (let j = pathArgIndices.length - 1; j >= 0; --j) {\n        const i = pathArgIndices[j];\n        args[i] = files.convertToOSPath(args[i]);\n      }\n\n      const shouldBeSync = alwaysSync || sync;\n      // There's some overhead in awaiting a Promise of an async call,\n      // vs just doing the sync call, which for a call like \"stat\"\n      // takes longer than the call itself.  Different parts of the tool\n      // may perform 1,000s or 10,000s of stats each under certain\n      // conditions, so we get a nice performance boost from making\n      // these calls sync.\n      const isQuickie = (fsFuncName === 'stat' ||\n                         fsFuncName === 'rename' ||\n                         fsFuncName === 'symlink');\n\n      const dirty = options && options.dirty;\n      const dirtyFn = typeof dirty === \"function\" ? dirty : null;\n\n      if (mayYield() &&\n          shouldBeSync &&\n          ! isQuickie) {\n        const promise = new Promise((resolve, reject) => {\n          args.push((err, value) => {\n            if (options.noErr) {\n              resolve(err);\n            } else if (err) {\n              reject(err);\n            } else {\n              resolve(value);\n            }\n          });\n\n          fsFunc.apply(fs, args);\n        });\n\n        const result = promise.await();\n\n        if (dirtyFn) {\n          dirtyFn(...args);\n        }\n\n        return options.modifyReturnValue\n          ? options.modifyReturnValue(result)\n          : result;\n\n      } else if (shouldBeSync) {\n        // Should be sync but can't yield: we are not in a Fiber.\n        // Run the sync version of the fs.* method.\n        const result = fsFuncSync.apply(fs, args);\n\n        if (dirtyFn) {\n          dirtyFn(...args);\n        }\n\n        return options.modifyReturnValue ?\n               options.modifyReturnValue(result) : result;\n\n      } else if (! sync) {\n        // wrapping a plain async version\n        let cb = args[args.length - 1];\n        if (typeof cb === \"function\") {\n          args.pop();\n        } else {\n          cb = null;\n        }\n\n        new Promise((resolve, reject) => {\n          args.push((err, res) => {\n            err ? reject(err) : resolve(res);\n          });\n\n          fsFunc.apply(fs, args);\n\n        }).then(res => {\n          if (dirtyFn) {\n            dirtyFn(...args);\n          }\n\n          if (options.modifyReturnValue) {\n            res = options.modifyReturnValue(res);\n          }\n\n          cb && cb(null, res);\n\n        }, cb);\n\n        return;\n      }\n\n      throw new Error('unexpected');\n    }\n\n    wrapper.displayName = fsFuncName;\n    return wrapper;\n  }\n\n  files[fsFuncName] = Profile('files.' + fsFuncName, makeWrapper({ alwaysSync: true }));\n\n  files.fsFixPath[fsFuncName] =\n    Profile('wrapped.fs.' + fsFuncName, makeWrapper({ sync: false }));\n  files.fsFixPath[fsFuncName + 'Sync'] =\n    Profile('wrapped.fs.' + fsFuncName + 'Sync', makeWrapper({ sync: true }));\n}\n\nlet dependOnPathSalt = 0;\nexport const dependOnPath = require(\"optimism\").wrap(\n  // Always return something different to prevent optimism from\n  // second-guessing the dirtiness of this function.\n  path => ++dependOnPathSalt\n);\n\nfunction wrapDestructiveFsFunc(name, pathArgIndices) {\n  pathArgIndices = pathArgIndices || [0];\n  wrapFsFunc(name, pathArgIndices, {\n    dirty(...args) {\n      // Immediately reset all optimistic functions (defined in\n      // tools/fs/optimistic.js) that depend on these paths.\n      pathArgIndices.forEach(i => dependOnPath.dirty(args[i]));\n    }\n  });\n}\n\nwrapDestructiveFsFunc(\"writeFile\");\nwrapDestructiveFsFunc(\"appendFile\");\n\nwrapFsFunc(\"readFile\", [0], {\n  modifyReturnValue: function (fileData) {\n    if (_.isString(fileData)) {\n      return files.convertToStandardLineEndings(fileData);\n    }\n\n    return fileData;\n  }\n});\n\nwrapFsFunc(\"stat\", [0]);\nwrapFsFunc(\"lstat\", [0]);\n\nwrapDestructiveFsFunc(\"rename\", [0, 1]);\n\n// After the outermost files.withCache call returns, the withCacheCache is\n// reset to null so that it does not survive server restarts.\nlet withCacheCache = null;\n\nfiles.withCache = Profile(\"files.withCache\", function (fn) {\n  const oldCache = withCacheCache;\n  withCacheCache = oldCache || Object.create(null);\n  try {\n    return fn();\n  } finally {\n    withCacheCache = oldCache;\n  }\n});\n\nfunction enableCache(name) {\n  const method = files[name];\n\n  function makeCacheKey(args) {\n    var parts = [name];\n\n    for (var i = 0; i < args.length; ++i) {\n      var arg = args[i];\n\n      if (typeof arg !== \"string\") {\n        // If any of the arguments is not a string, then we won't cache\n        // the result of the corresponding file.* method invocation.\n        return null;\n      }\n\n      parts.push(arg);\n    }\n\n    return parts.join(\"\\0\");\n  }\n\n  files[name] = function (...args) {\n    if (withCacheCache) {\n      var cacheKey = makeCacheKey(args);\n      if (cacheKey && cacheKey in withCacheCache) {\n        return withCacheCache[cacheKey];\n      }\n    }\n\n    const result = method.apply(files, args);\n\n    if (withCacheCache && cacheKey !== null) {\n      // If cacheKey === null, then we called makeCacheKey above and it\n      // failed because one of the arguments was not a string, so we\n      // should not try to call makeCacheKey again.\n      withCacheCache[cacheKey || makeCacheKey(args)] = result;\n    }\n\n    return result;\n  };\n}\n\nenableCache(\"readdir\");\nenableCache(\"realpath\");\nenableCache(\"stat\");\nenableCache(\"lstat\");\n\n// The fs.exists method is deprecated in Node v4:\n// https://nodejs.org/api/fs.html#fs_fs_exists_path_callback\nfiles.exists =\nfiles.existsSync = function (path, callback) {\n  if (typeof callback === \"function\") {\n    throw new Error(\"Passing a callback to files.exists is no longer supported\");\n  }\n  return !! files.statOrNull(path);\n};\n\nif (files.isWindowsLikeFilesystem()) {\n  const rename = files.rename;\n\n  files.rename = function (from, to) {\n    // Retries are necessary only on Windows, because the rename call can\n    // fail with EBUSY, which means the file is in use.\n    let maxTries = 10;\n    let success = false;\n    const osTo = files.convertToOSPath(to);\n\n    while (! success && maxTries-- > 0) {\n      try {\n        // Despite previous failures, the top-level destination directory\n        // may have been successfully created, so we must remove it to\n        // avoid moving the source file *into* the destination directory.\n        rimraf.sync(osTo);\n        rename(from, to);\n        success = true;\n      } catch (err) {\n        if (err.code !== 'EPERM' && err.code !== 'EACCES') {\n          throw err;\n        }\n      }\n    }\n\n    if (! success) {\n      files.cp_r(from, to);\n      files.rm_recursive(from);\n    }\n  };\n}\n\n// Warning: doesn't convert slashes in the second 'cache' arg\nwrapFsFunc(\"realpath\", [0], {\n  modifyReturnValue: files.convertToStandardPath\n});\n\nwrapFsFunc(\"readdir\", [0], {\n  modifyReturnValue: function (entries) {\n    return _.map(entries, files.convertToStandardPath);\n  }\n});\n\nwrapDestructiveFsFunc(\"rmdir\");\nwrapDestructiveFsFunc(\"mkdir\");\nwrapDestructiveFsFunc(\"unlink\");\nwrapDestructiveFsFunc(\"chmod\");\n\nwrapFsFunc(\"open\", [0]);\n\n// XXX this doesn't give you the second argument to the callback\nwrapFsFunc(\"read\", []);\nwrapFsFunc(\"write\", []);\nwrapFsFunc(\"close\", []);\nwrapFsFunc(\"symlink\", [0, 1]);\nwrapFsFunc(\"readlink\", [0]);\n\n// These don't need to be Fiberized\nfiles.createReadStream = function (...args) {\n  args[0] = files.convertToOSPath(args[0]);\n  return fs.createReadStream(...args);\n};\n\nfiles.createWriteStream = function (...args) {\n  args[0] = files.convertToOSPath(args[0]);\n  return fs.createWriteStream(...args);\n};\n\nfiles.watchFile = function (...args) {\n  args[0] = files.convertToOSPath(args[0]);\n  return fs.watchFile(...args);\n};\n\nfiles.unwatchFile = function (...args) {\n  args[0] = files.convertToOSPath(args[0]);\n  return fs.unwatchFile(...args);\n};\n\nfiles.readBufferWithLengthAndOffset = function (filename, length, offset) {\n  var data = new Buffer(length);\n  // Read the data from disk, if it is non-empty. Avoid doing IO for empty\n  // files, because (a) unnecessary and (b) fs.readSync with length 0\n  // throws instead of acting like POSIX read:\n  // https://github.com/joyent/node/issues/5685\n  if (length > 0) {\n    var fd = files.open(filename, \"r\");\n    try {\n      var count = files.read(\n        fd, data, 0, length, offset);\n    } finally {\n      files.close(fd);\n    }\n    if (count !== length) {\n      throw new Error(\"couldn't read entire resource\");\n    }\n  }\n  return data;\n};\n"]}