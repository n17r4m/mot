{"version":3,"sources":["meteor://ðŸ’»app/packages/compileStylusBatch/plugin/compile-stylus.js"],"names":["stylus","Npm","require","nib","autoprefixer","Future","fs","Plugin","path","registerCompiler","extensions","archMatching","StylusCompiler","MultiFileCachingCompiler","constructor","compilerName","defaultCacheSize","getCacheKey","inputFile","getSourceHash","getFileOptions","compileResultSize","compileResult","css","length","sourceMapSize","sourceMap","isRoot","fileOptions","hasOwnProperty","isImport","pathInPackage","getPathInPackage","test","compileOneFile","allFiles","referencedImportPaths","parseImportPath","filePath","importerDir","Error","packageName","getPackageName","match","parsedImporter","importPath","join","exec","ignored","absoluteImportPath","parsed","importer","find","paths","i","joined","statOrNull","absolutePath","has","readFile","isAbsolute","isNib","indexOf","isStylusBuiltIn","readFileSync","push","getDisplayPath","get","getContentsAsString","processSourcemap","sourcemap","file","sourcesContent","sources","map","f","style","use","set","inline","comment","render","resolver","wait","e","error","message","addCompileResult","addStylesheet","data","statSync"],"mappings":"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","file":"/packages/compileStylusBatch_plugin.js","sourcesContent":["const stylus = Npm.require('stylus');\nconst nib = Npm.require('nib');\nconst autoprefixer = Npm.require('autoprefixer-stylus');\nconst Future = Npm.require('fibers/future');\nconst fs = Plugin.fs;\nconst path = Plugin.path;\n\nPlugin.registerCompiler({\n  extensions: ['styl'],\n  archMatching: 'web'\n}, () => new StylusCompiler());\n\n// CompileResult is {css, sourceMap}.\nclass StylusCompiler extends MultiFileCachingCompiler {\n  constructor() {\n    super({\n      compilerName: 'stylus',\n      defaultCacheSize: 1024*1024*10,\n    });\n  }\n\n  getCacheKey(inputFile) {\n    return [\n      inputFile.getSourceHash(),\n      inputFile.getFileOptions(),\n    ];\n  }\n\n  compileResultSize(compileResult) {\n    return compileResult.css.length +\n      this.sourceMapSize(compileResult.sourceMap);\n  }\n\n  // The heuristic is that a file is an import (ie, is not itself\n  // processed as a root) if it matches *.import.styl.  This can be\n  // overridden in either direction via an explicit `isImport` file option\n  // in api.addFiles.\n  isRoot(inputFile) {\n    const fileOptions = inputFile.getFileOptions();\n    if (fileOptions.hasOwnProperty('isImport')) {\n      return !fileOptions.isImport;\n    }\n\n    const pathInPackage = inputFile.getPathInPackage();\n    return ! /\\.import\\.styl$/.test(pathInPackage);\n  }\n\n  compileOneFile(inputFile, allFiles) {\n    const referencedImportPaths = [];\n\n    function parseImportPath(filePath, importerDir) {\n      if (! filePath) {\n        throw new Error('filePath is undefined');\n      }\n      if (filePath === inputFile.getPathInPackage()) {\n        return {\n          packageName: inputFile.getPackageName() || '',\n          pathInPackage: inputFile.getPathInPackage()\n        };\n      }\n      if (! filePath.match(/^\\{.*\\}\\//)) {\n        if (! importerDir) {\n          return { packageName: inputFile.getPackageName() || '',\n                   pathInPackage: filePath };\n        }\n\n        // relative path in the same package\n        const parsedImporter = parseImportPath(importerDir, null);\n\n        // resolve path if it is absolute or relative\n        const importPath =\n          (filePath[0] === '/') ? filePath :\n            path.join(parsedImporter.pathInPackage, filePath);\n\n        return {\n          packageName: parsedImporter.packageName,\n          pathInPackage: importPath\n        };\n      }\n\n      const match = /^\\{(.*)\\}\\/(.*)$/.exec(filePath);\n      if (! match) { return null; }\n\n      const [ignored, packageName, pathInPackage] = match;\n      return {packageName, pathInPackage};\n    }\n    function absoluteImportPath(parsed) {\n      return '{' + parsed.packageName + '}/' + parsed.pathInPackage;\n    }\n\n    const importer = {\n      find(importPath, paths) {\n        const parsed = parseImportPath(importPath, paths[paths.length - 1]);\n        if (! parsed) { return null; }\n\n        if (importPath[0] !== '{') {\n          // if it is not a custom syntax path, it could be a lookup in a folder\n          for (let i = paths.length - 1; i >= 0; i--) {\n            const joined = path.join(paths[i], importPath);\n            if (statOrNull(joined)) {\n              return [joined];\n            }\n          }\n        }\n\n        const absolutePath = absoluteImportPath(parsed);\n\n        if (! allFiles.has(absolutePath)) {\n          return null;\n        }\n\n        return [absolutePath];\n      },\n      readFile(filePath) {\n        const isAbsolute = filePath[0] === '/';\n        const isNib =\n                filePath.indexOf('/node_modules/nib/lib/nib/') !== -1;\n        const isStylusBuiltIn =\n                filePath.indexOf('/node_modules/stylus/lib/') !== -1;\n\n        if (isAbsolute || isNib || isStylusBuiltIn) {\n          // absolute path? let the default implementation handle this\n          return fs.readFileSync(filePath, 'utf8');\n        }\n\n        const parsed = parseImportPath(filePath);\n        const absolutePath = absoluteImportPath(parsed);\n\n        referencedImportPaths.push(absolutePath);\n\n        if (! allFiles.has(absolutePath)) {\n          throw new Error(\n            `Cannot read file ${absolutePath} for ${inputFile.getDisplayPath()}`\n          );\n        }\n\n        return allFiles.get(absolutePath).getContentsAsString();\n      }\n    };\n\n    function processSourcemap(sourcemap) {\n      delete sourcemap.file;\n      sourcemap.sourcesContent = sourcemap.sources.map(importer.readFile);\n      sourcemap.sources = sourcemap.sources.map((filePath) => {\n        const parsed = parseImportPath(filePath);\n        if (!parsed.packageName)\n          return parsed.pathInPackage;\n        return 'packages/' + parsed.packageName + '/' + parsed.pathInPackage;\n      });\n\n      return sourcemap;\n    }\n\n    const fileOptions = inputFile.getFileOptions();\n\n    const f = new Future;\n\n    let style = stylus(inputFile.getContentsAsString()).use(nib())\n\n    if (fileOptions.autoprefixer) {\n      style = style.use(autoprefixer(fileOptions.autoprefixer))\n    }\n\n    style = style.set('filename', inputFile.getPathInPackage())\n                 .set('sourcemap', { inline: false, comment: false })\n                 .set('cache', false)\n                 .set('importer', importer);\n\n    style.render(f.resolver());\n    let css;\n    try {\n      css = f.wait();\n    } catch (e) {\n      inputFile.error({\n        message: 'Stylus compiler error: ' + e.message\n      });\n      return null;\n    }\n    const sourceMap = processSourcemap(style.sourcemap);\n    return {referencedImportPaths, compileResult: {css, sourceMap}};\n  }\n\n  addCompileResult(inputFile, {css, sourceMap}) {\n    inputFile.addStylesheet({\n      path: inputFile.getPathInPackage() + '.css',\n      data: css,\n      sourceMap: sourceMap\n    });\n  }\n}\n\nfunction statOrNull(path) {\n  try {\n    return fs.statSync(path);\n  } catch (e) {\n    return null;\n  }\n}\n"]}